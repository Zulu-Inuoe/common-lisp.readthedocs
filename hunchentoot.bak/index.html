<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>hunchentoot - The Common Lisp web server (formerly TBNL) - common-lisp.readthedocs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "hunchentoot - The Common Lisp web server (formerly TBNL)";
    var mkdocs_page_input_path = "hunchentoot.bak.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> common-lisp.readthedocs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">index</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Defacto libraries</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../alexandria/">Alexandria Manual - draft version</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../bordeaux-threads/">bordeaux-threads</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../hunchentoot/">hunchentoot - The Common Lisp web server (formerly TBNL)</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">common-lisp.readthedocs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>hunchentoot - The Common Lisp web server (formerly TBNL)</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="hunchentoot-the-common-lisp-web-server-formerly-tbnl">hunchentoot - The Common Lisp web server (formerly TBNL)</h1>
<p>Version: 1.2.38</p>
<h2 id="introduction">INTRODUCTION</h2>
<p>Hunchentoot is a web server written in Common Lisp and at the same
time a toolkit for building dynamic websites.  As a stand-alone web
server, Hunchentoot is capable of HTTP/1.1 chunking (both directions),
persistent connections (keep-alive), and SSL.</p>
<p>Hunchentoot provides facilities like automatic session handling (with
and without cookies), logging, customizable error handling, and easy
access to GET and POST parameters sent by the client. It does <em>not</em>
include functionality to programmatically generate HTML output. For
this task you can use any library you like,
e.g. <a href="https://github.com/edicl/cl-who/">CL-WHO</a> or
<a href="https://github.com/edicl/html-template/">HTML-TEMPLATE</a>.</p>
<p>Hunchentoot talks with its front-end or with the client over TCP/IP
sockets and optionally uses multiprocessing to handle several requests
at the same time.  Therefore, it cannot be implemented completely in
<a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">portable Common
Lisp</a>.
It currently works with <a href="http://www.lispworks.com/">LispWorks</a> and all
Lisps which are supported by the compatibility layers
<a href="http://common-lisp.net/project/usocket/">usocket</a> and <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
Threads</a>.</p>
<p>Hunchentoot comes with a <a href="http://www.opensource.org/licenses/bsd-license.php">BSD-style
license</a> so you
can basically do with it whatever you want.</p>
<p>Complete documentation for Hunchentoot including details about how to
install it can be found in the <code>docs</code> directory or at the <a href="https://edicl.github.io/hunchentoot/">project
website</a>.</p>
<h3 id="download-and-installation">Download and Installation</h3>
<pre><code class="lisp">(ql:quickload :hunchentoot)
</code></pre>

<p>Hunchentoot will only work with Lisps where the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#character_code">character
codes</a>
of all <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">Latin-1</a> characters
coincide with their Unicode <a href="http://en.wikipedia.org/wiki/Code_point">code
points</a> (which is the case for
all current implementations I know).</p>
<p>Source code can be downloaded from <a href="https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz">https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz</a>.</p>
<p>The current development version of Hunchentoot can be found at
<a href="https://github.com/edicl/hunchentoot">https://github.com/edicl/hunchentoot</a>. If you want to send patches,
please fork the github repository and send pull requests.</p>
<h4 id="without-clssl">Without cl+ssl</h4>
<p>You can compile Hunchentoot without
SSL support - and thus without the need to have CL+SSL - if you add
<code>:HUNCHENTOOT-NO-SSL</code> to
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm"><code>*FEATURES*</code></a>
<em>before</em> you compile it.</p>
<h4 id="clbuild">clbuild</h4>
<p>Hunchentoot and its dependencies can also be installed with
<a href="http://common-lisp.net/project/clbuild/">clbuild</a>. </p>
<h4 id="gentoo-linux">Gentoo Linux</h4>
<p>There's also a port
for <a href="http://www.gentoo.org/proj/en/lisp/common-lisp/index.xml">Gentoo Linux</a> thanks
to Matthew Kennedy.</p>
<h4 id="running-hunchentoot-on-port-80">Running Hunchentoot on port 80</h4>
<p>Hunchentoot does not come with code to help with running it on a
privileged port (i.e. port 80 or 443) on Unix-like operating systems.
Modern Unix-like systems have specific, non-portable ways to allow
non-root users to listen to privileged ports, so including such
functionality in Hunchentoot was considered unnecessary. Please refer to
online resources for help. At the time of this writing, the YAWS
documentation has a <a href="http://yaws.hyber.org/privbind.yaws">comprehensive
writeup</a> on the topic.</p>
<h4 id="hunchentoot-behind-a-proxy">Hunchentoot behind a proxy</h4>
<p>If you're feeling unsecure about exposing Hunchentoot to the wild, wild
Internet or if your Lisp web application is part of a larger website,
you can hide it behind a <a href="http://en.wikipedia.org/wiki/Proxy_server">proxy
server</a>. One approach that I
have used several times is to employ Apache's
<a href="http://httpd.apache.org/docs/current/mod/mod_proxy.html">mod_proxy</a>
module with a configuration that looks like this:</p>
<pre><code>ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot
ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot
</code></pre>
<p>This will tunnel all requests where the URI path begins with
<code>"/hunchentoot"</code> to a (Hunchentoot) server listening on portÂ 3000 on the
same machine.</p>
<p>Of course, there are <a href="http://www.red-bean.com/pipermail/lispweb/2006-October/001342.html">several
other</a>
(more lightweight) web proxies that you could use instead of Apache.</p>
<h3 id="support">Support</h3>
<p>The development version of Hunchentoot can be found <a href="https://github.com/edicl/hunchentoot">on
github</a>. Please use the github
issue tracking system to submit bug reports. Patches are welcome, please
use <a href="https://github.com/edicl/hunchentoot/pulls">GitHub pull requests</a>.
If you want to make a change, please <a href="http://weitz.de/patches.html">read this
first</a>.</p>
<h2 id="more-documentation-tutorials-and-add-ons">MORE DOCUMENTATION, TUTORIALS AND ADD-ONS</h2>
<ul>
<li>Adam Petersen has written a book called <a href="http://www.adampetersen.se/articles/lispweb.htm">"Lisp for the
Web"</a> which explains
how Hunchentoot and some other libraries can be used to build web sites.</li>
<li>See also the <a href="http://lispcookbook.github.io/cl-cookbook/web.html">Web Development - Cookbook</a>.</li>
<li><a href="https://roeim.net/vetle/docs/cl-webapp-intro/part-1/">Implementing a blog in Common Lisp - Vetle Roeim</a></li>
</ul>
<p>Extensions and related softwares:</p>
<ul>
<li><a href="https://github.com/fukamachi/clack">Clack</a> is a web server
    abstraction layer, defaulting to Hunchentoot.</li>
<li><a href="https://github.com/slyrus/hunchentoot-cgi">hunchentoot-cgi</a> (by 
        Cyrus Harmo) provides
    <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>
    handlers for Hunchentoot.</li>
<li><a href="http://weitz.de/cl-webdav/">CL-WEBDAV</a> is a
    <a href="http://webdav.org/">WebDAV</a> server based on Hunchentoot.</li>
<li><a href="http://restas.lisper.ru/">RESTAS</a> is a web framework based on
    Hunchentoot. <a href="https://github.com/fukamachi/caveman">Caveman</a>,
    <a href="https://github.com/Shirakumo/radiance">Radiance</a>,
    <a href="https://github.com/joaotavora/snooze">Snooze</a> or again
    <a href="http://40ants.com/weblocks/">Weblocks</a> are frameworks compatible
    with it.</li>
</ul>
<h2 id="api-reference">API REFERENCE</h2>
<h3 id="1-acceptor">1. ACCEPTOR</h3>
<pre><code class="lisp">Class
</code></pre>

<p>To create a Hunchentoot webserver, you make an
instance of this class and use the generic function START to start it
(and STOP to stop it).  Use the :PORT initarg if you don't want to
listen on the default http port 80.  There are other initargs most of
which you probably won't need very often.  They are explained in
detail in the docstrings of the slot definitions for this class.</p>
<p>Unless you are in a Lisp without MP capabilities, you can have several
active instances of ACCEPTOR (listening on different ports) at the
same time.</p>
<h4 id="port">port</h4>
<pre><code class="lisp">Initargs: :port
Readers: hunchentoot:acceptor-port
</code></pre>

<p>The port the acceptor is listening on.  The
 default is 80.  Note that depending on your operating system you might
 need special privileges to listen on port 80.  When 0, the port will be
 chosen by the system the first time the acceptor is started.</p>
<h4 id="address">address</h4>
<pre><code class="lisp">Initargs: :address
Readers: hunchentoot:acceptor-address
</code></pre>

<p>The address the acceptor is listening on.
 If address is a string denoting an IP address, then the server only
 receives connections for that address.  This must be one of the
 addresses associated with the machine and allowed values are host
 names such as "www.zappa.com" and address strings such as
 "72.3.247.29".  If address is NIL, then the server will receive
 connections to all IP addresses on the machine. This is the default.</p>
<h4 id="name">name</h4>
<pre><code class="lisp">Initargs: :name
Readers: hunchentoot:acceptor-name
Writers: (setf hunchentoot:acceptor-name)
</code></pre>

<p>The optional name of the acceptor, a symbol.
 This name can be utilized when defining "easy handlers" - see
 DEFINE-EASY-HANDLER.  The default name is an uninterned symbol as
 returned by GENSYM.</p>
<h4 id="request-class">request-class</h4>
<pre><code class="lisp">Initargs: :request-class
Readers: hunchentoot:acceptor-request-class
Writers: (setf hunchentoot:acceptor-request-class)
</code></pre>

<p>Determines which class of request
 objects is created when a request comes in and should be (a symbol
 naming) a class which inherits from REQUEST.  The default is the
 symbol REQUEST.</p>
<h4 id="reply-class">reply-class</h4>
<pre><code class="lisp">Initargs: :reply-class
Readers: hunchentoot:acceptor-reply-class
Writers: (setf hunchentoot:acceptor-reply-class)
</code></pre>

<p>Determines which class of reply
 objects is created when a request is served in and should be (a
 symbol naming) a class which inherits from REPLY.  The default is the
 symbol REPLY.
  HUNCHENTOOT:TASKMASTER
Initargs: :taskmasterdocumentation:
 The taskmaster (i.e. an instance of a
 subclass of TASKMASTER) that is responsible for scheduling the work
 for this acceptor.  The default depends on the MP capabilities of the
 underlying Lisp.</p>
<h4 id="output-chunking-p">output-chunking-p</h4>
<pre><code class="lisp">Initargs: :output-chunking-p
Readers: hunchentoot:acceptor-output-chunking-p
Writers: (setf hunchentoot:acceptor-output-chunking-p)
</code></pre>

<p>A generalized boolean denoting
 whether the acceptor may use chunked encoding for output, i.e. when
 sending data to the client.  The default is T and there's usually no
 reason to change this to NIL.</p>
<h4 id="input-chunking-p">input-chunking-p</h4>
<pre><code class="lisp">Initargs: :input-chunking-p
Readers: hunchentoot:acceptor-input-chunking-p
Writers: (setf hunchentoot:acceptor-input-chunking-p)
</code></pre>

<p>A generalized boolean denoting
 whether the acceptor may use chunked encoding for input, i.e. when
 accepting request bodies from the client.  The default is T and
 there's usually no reason to change this to NIL.</p>
<h4 id="persistent-connections-p">persistent-connections-p</h4>
<pre><code class="lisp">Initargs: :persistent-connections-p
Readers: hunchentoot:acceptor-persistent-connections-p
Writers: (setf hunchentoot:acceptor-persistent-connections-p)
</code></pre>

<p>A generalized boolean
 denoting whether the acceptor supports persistent connections, which
 is the default for threaded acceptors.  If this property is NIL,
 Hunchentoot closes each incoming connection after having processed one
 request.  This is the default for non-threaded acceptors.</p>
<h4 id="read-timeout">read-timeout</h4>
<pre><code class="lisp">Initargs: :read-timeout
Readers: hunchentoot:acceptor-read-timeout
</code></pre>

<p>The read timeout of the acceptor,
 specified in (fractional) seconds.  The precise semantics of this
 parameter is determined by the underlying Lisp's implementation of
 socket timeouts.  NIL means no timeout.</p>
<h4 id="write-timeout">write-timeout</h4>
<pre><code class="lisp">Initargs: :write-timeout
Readers: hunchentoot:acceptor-write-timeout
</code></pre>

<p>The write timeout of the acceptor,
 specified in (fractional) seconds.  The precise semantics of this
 parameter is determined by the underlying Lisp's implementation of
 socket timeouts.  NIL means no timeout.</p>
<h4 id="listen-socket">listen-socket</h4>
<pre><code class="lisp"></code></pre>

<p>The socket listening for incoming
 connections.</p>
<h4 id="listen-backlog">listen-backlog</h4>
<pre><code class="lisp">Initargs: :listen-backlog
Readers: hunchentoot:acceptor-listen-backlog
</code></pre>

<p>Number of pending connections
   allowed in the listen socket before the kernel rejects
   further incoming connections.</p>
<h4 id="acceptor-shutdown-p">acceptor-shutdown-p</h4>
<pre><code class="lisp">Initform: T
</code></pre>

<p>A flag that makes the acceptor
 shutdown itself when set to something other than NIL.</p>
<h4 id="requests-in-progress">requests-in-progress</h4>
<pre><code class="lisp">Initform: 0
</code></pre>

<p>The number of
 requests currently in progress.</p>
<h4 id="shutdown-queue">shutdown-queue</h4>
<pre><code class="lisp"></code></pre>

<p>A condition variable
 used with soft shutdown, signaled when all requests
 have been processed.</p>
<h4 id="shutdown-lock">shutdown-lock</h4>
<pre><code class="lisp"></code></pre>

<p>The lock protecting the shutdown-queue
 condition variable and the requests-in-progress counter.</p>
<h4 id="access-log-destination">access-log-destination</h4>
<pre><code class="lisp">Initargs: :access-log-destination
Readers: hunchentoot:acceptor-access-log-destination
Writers: (setf hunchentoot:acceptor-access-log-destination)
</code></pre>

<p>Destination of the access log
 which contains one log entry per request handled in a format similar
 to Apache's access.log.  Can be set to a pathname or string
 designating the log file, to a open output stream or to NIL to
 suppress logging.</p>
<h4 id="message-log-destination">message-log-destination</h4>
<pre><code class="lisp">Initargs: :message-log-destination
Readers: hunchentoot:acceptor-message-log-destination
Writers: (setf hunchentoot:acceptor-message-log-destination)
</code></pre>

<p>Destination of the server
 error log which is used to log informational, warning and error
 messages in a free-text format intended for human inspection. Can be
 set to a pathname or string designating the log file, to a open output
 stream or to NIL to suppress logging.</p>
<h4 id="error-template-directory">error-template-directory</h4>
<pre><code class="lisp">Initargs: :error-template-directory
Readers: hunchentoot:acceptor-error-template-directory
Writers: (setf hunchentoot:acceptor-error-template-directory)
</code></pre>

<p>Directory pathname that
  contains error message template files for server-generated error
  messages.  Files must be named <return-code>.html with <return-code>
  representing the HTTP return code that the file applies to,
  i.e. 404.html would be used as the content for a HTTP 404 Not found
  response.</p>
<h4 id="document-root">document-root</h4>
<pre><code class="lisp">Initargs: :document-root
Readers: hunchentoot:acceptor-document-root
Writers: (setf hunchentoot:acceptor-document-root)
</code></pre>

<p>Directory pathname that points to
 files that are served by the acceptor if no more specific
 acceptor-dispatch-request method handles the request.#### acceptor-access-log-destination</p>
<h3 id="2-easy-acceptor">2. EASY-ACCEPTOR</h3>
<pre><code class="lisp">Class
</code></pre>

<p>This is the acceptor of the "easy" Hunchentoot framework.</p>
<pre><code class="lisp">Direct superclasses: HUNCHENTOOT:ACCEPTOR
Direct subclasses: HUNCHENTOOT:EASY-SSL-ACCEPTOR

</code></pre>

<h3 id="3-define-easy-handler">3. DEFINE-EASY-HANDLER</h3>
<pre><code class="lisp">Function: (define-easy-handler description lambda-list &amp;body body)
</code></pre>

<p>Defines a handler with the body BODY and optionally registers
it with a URI so that it will be found by DISPATCH-EASY-HANDLERS.
DESCRIPTION is either a symbol NAME or a list matching the
destructuring lambda list</p>
<pre><code class="lisp">  (name &amp;key uri acceptor-names default-parameter-type default-request-type)
</code></pre>

<p>LAMBDA-LIST is a list the elements of which are either a symbol
VAR or a list matching the destructuring lambda list</p>
<pre><code class="lisp">  (var &amp;key real-name parameter-type init-form request-type)
</code></pre>

<p>The resulting handler will be a Lisp function with the name NAME
and keyword parameters named by the VAR symbols.  Each VAR will
be bound to the value of the GET or POST parameter called
REAL-NAME (a string) before BODY is executed.  If REAL-NAME is
not provided, it will be computed by downcasing the symbol name
of VAR.</p>
<p>If URI (which is evaluated) is provided, then it must be a string or
a function designator for a function of one argument.  In this case,
the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a
string and the script name of a request is URI, or if URI designates a
function and applying this function to the current request object
returns a true value.</p>
<p>ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which
means that the handler will be returned by DISPATCH-EASY-HANDLERS in
acceptors which have one of these names (see ACCEPTOR-NAME).
ACCEPTOR-NAMES can also be the symbol T which means that the handler
will be returned by DISPATCH-EASY-HANDLERS in every acceptor.</p>
<p>Whether the GET or POST parameter (or both) will be taken into
consideration, depends on REQUEST-TYPE which can
be :GET, :POST, :BOTH, or NIL.  In the last case, the value of
DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be
used.</p>
<p>The value of VAR will usually be a string (unless it resulted from a
file upload in which case it won't be converted at all), but if
PARAMETER-TYPE (which is evaluated) is provided, the string will be
converted to another Lisp type by the following rules:</p>
<p>If the corresponding GET or POST parameter wasn't provided by the
client, VAR's value will be NIL.  If PARAMETER-TYPE is 'STRING, VAR's
value remains as is.  If PARAMETER-TYPE is 'INTEGER and the parameter
string consists solely of decimal digits, VAR's value will be the
corresponding integer, otherwise NIL.  If PARAMETER-TYPE is 'KEYWORD,
VAR's value will be the keyword obtained by interning the upcased
parameter string into the keyword package.  If PARAMETER-TYPE is
'CHARACTER and the parameter string is of length one, VAR's value will
be the single character of this string, otherwise NIL.  If
PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it
is NIL by the first rule above, of course).  If PARAMETER-TYPE is any
other atom, it is supposed to be a function designator for a unary
function which will be called to convert the string to something else.</p>
<p>Those were the rules for <code>simple' types, but PARAMETER-TYPE can
also be a list starting with one of the symbols LIST, ARRAY, or
HASH-TABLE.  The second value of the list must always be a simple
parameter type as in the last paragraph - we'll call it the</code>inner type' below.</p>
<p>In the case of 'LIST, all GET/POST parameters called REAL-NAME
will be collected, converted to the inner type, and assembled
into a list which will be the value of VAR.</p>
<p>In the case of 'ARRAY, all GET/POST parameters which have a name
like the result of</p>
<pre><code class="lisp">  (format nil &quot;~A[~A]&quot; real-name n)
</code></pre>

<p>where N is a non-negative integer, will be assembled into an
array where the Nth element will be set accordingly, after
conversion to the inner type.  The array, which will become the
value of VAR, will be big enough to hold all matching parameters,
but not bigger.  Array elements not set as described above will
be NIL.  Note that VAR will always be bound to an array, which
may be empty, so it will never be NIL, even if no appropriate
GET/POST parameters are found.</p>
<p>The full form of a 'HASH-TABLE parameter type is</p>
<pre><code class="lisp">  (hash-table inner-type key-type test-function),
</code></pre>

<p>but KEY-TYPE and TEST-FUNCTION can be left out in which case they
default to 'STRING and 'EQUAL, respectively.  For this parameter
type, all GET/POST parameters which have a name like the result
of</p>
<pre><code class="lisp">  (format nil &quot;~A{~A}&quot; real-name key)
</code></pre>

<p>(where KEY is a string that doesn't contain curly brackets) will
become the values (after conversion to INNER-TYPE) of a hash
table with test function TEST-FUNCTION where KEY (after
conversion to KEY-TYPE) will be the corresponding key.  Note that
VAR will always be bound to a hash table, which may be empty, so
it will never be NIL, even if no appropriate GET/POST parameters
are found.</p>
<p>To make matters even more complicated, the three compound
parameter types also have an abbreviated form - just one of the
symbols LIST, ARRAY, or HASH-TABLE.  In this case, the inner type
will default to 'STRING.</p>
<p>If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE
(the default of which is 'STRING) will be used instead.</p>
<p>If the result of the computations above would be that VAR would
be bound to NIL, then INIT-FORM (if provided) will be evaluated
instead, and VAR will be bound to the result of this evaluation.</p>
<p>Handlers built with this macro are constructed in such a way that
the resulting Lisp function is useful even outside of
Hunchentoot.  Specifically, all the parameter computations above
will only happen if *REQUEST* is bound, i.e. if we're within a
Hunchentoot request.  Otherwise, VAR will always be bound to the
result of evaluating INIT-FORM unless a corresponding keyword
argument is provided.</p>
<h3 id="4-ssl-acceptor">4. SSL-ACCEPTOR</h3>
<pre><code class="lisp">Class
</code></pre>

<p>Create and START an instance of this class
(instead of ACCEPTOR) if you want an https server.  There are two
required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for
pathname designators denoting the certificate file and the key file in
PEM format.  On LispWorks, you can have both in one file in which case
the second initarg is optional.  You can also use the
:SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string)
for the key file (or NIL, the default, for no password).</p>
<p>The default port for SSL-ACCEPTOR instances is 443 instead of 80</p>
<h4 id="ssl-certificate-file">ssl-certificate-file</h4>
<pre><code class="lisp">Initargs: :ssl-certificate-file
Readers: hunchentoot:acceptor-ssl-certificate-file
</code></pre>

<p>A pathname designator for a
 certificate file in PEM format.</p>
<h4 id="ssl-privatekey-file">ssl-privatekey-file</h4>
<pre><code class="lisp">Initargs: :ssl-privatekey-file
Readers: hunchentoot:acceptor-ssl-privatekey-file
</code></pre>

<p>A pathname designator for a
 private key file in PEM format, or (only on LispWorks) NIL if the
 certificate file contains the private key.</p>
<h4 id="ssl-privatekey-password">ssl-privatekey-password</h4>
<pre><code class="lisp">Initargs: :ssl-privatekey-password
Readers: hunchentoot:acceptor-ssl-privatekey-password
</code></pre>

<p>The password for the
 private key file or NIL for no password.</p>
<h4 id="ssl-certificate-file_1">ssl-certificate-file</h4>
<pre><code class="lisp">Initargs: :ssl-certificate-file
Readers: hunchentoot:acceptor-ssl-certificate-file
</code></pre>

<p>A pathname designator for a
 certificate file in PEM format.</p>
<h4 id="ssl-privatekey-file_1">ssl-privatekey-file</h4>
<pre><code class="lisp">Initargs: :ssl-privatekey-file
Readers: hunchentoot:acceptor-ssl-privatekey-file
</code></pre>

<p>A pathname designator for a
 private key file in PEM format, or (only on LispWorks) NIL if the
 certificate file contains the private key.</p>
<h4 id="ssl-privatekey-password_1">ssl-privatekey-password</h4>
<pre><code class="lisp">Initargs: :ssl-privatekey-password
Readers: hunchentoot:acceptor-ssl-privatekey-password
</code></pre>

<p>The password for the
 private key file or NIL for no password.</p>
<h3 id="5-easy-ssl-acceptor">5. EASY-SSL-ACCEPTOR</h3>
<pre><code class="lisp">Class
</code></pre>

<p>This is an acceptor that mixes the "easy" Hunchentoot with SSL connections.</p>
<h3 id="6-reply">6. REPLY</h3>
<pre><code class="lisp">Class
</code></pre>

<p>Objects of this class hold all the information
about an outgoing reply.  They are created automatically by
Hunchentoot and can be accessed and modified by the corresponding
handler.</p>
<p>You should not mess with the slots of these objects directly, but you
can subclass REPLY in order to implement your own behaviour.  See the
REPLY-CLASS slot of the ACCEPTOR class.</p>
<h4 id="content-type">content-type</h4>
<pre><code class="lisp">Readers: hunchentoot:content-type
</code></pre>

<p>The outgoing 'Content-Type' http
 header which defaults to the value of *DEFAULT-CONTENT-TYPE*.</p>
<h4 id="content-length">content-length</h4>
<pre><code class="lisp">Readers: hunchentoot:content-length
</code></pre>

<p>The outgoing 'Content-Length'
 http header which defaults NIL.  If this is NIL, Hunchentoot will
 compute the content length.</p>
<h4 id="headers-out">headers-out</h4>
<pre><code class="lisp">Readers: hunchentoot:headers-out
</code></pre>

<p>An alist of the outgoing http headers
 not including the 'Set-Cookie', 'Content-Length', and 'Content-Type'
 headers.  Use the functions HEADER-OUT and (SETF HEADER-OUT) to
 modify this slot.</p>
<h4 id="return-code">return-code</h4>
<pre><code class="lisp">Initform: hunchentoot:+http-ok+
Readers: hunchentoot:return-code
Writers: (setf hunchentoot:return-code)
</code></pre>

<p>The http return code of this
 reply.  The return codes Hunchentoot can handle are defined in
 specials.lisp.</p>
<h4 id="external-format">external-format</h4>
<pre><code class="lisp">Initform: hunchentoot:*hunchentoot-default-external-format*
Readers: hunchentoot:reply-external-format
Writers: (setf hunchentoot:reply-external-format)
</code></pre>

<p>The external format of the reply -
 used for character output.</p>
<h4 id="cookies-out">cookies-out</h4>
<pre><code class="lisp">Readers: hunchentoot:cookies-out
Writers: (setf hunchentoot:cookies-out)
</code></pre>

<p>The outgoing cookies.  This slot's
 value should only be modified by the functions defined in
 cookies.lisp.</p>
<h4 id="reply-external-format">reply-external-format*</h4>
<pre><code class="lisp">Function: (reply-external-format* &amp;optional (reply *reply*))
</code></pre>

<p>The external format of REPLY which is used for character output.</p>
<h3 id="7-request">7. REQUEST</h3>
<pre><code class="lisp">Class
</code></pre>

<p>Objects of this class hold all the information
about an incoming request.  They are created automatically by
acceptors and can be accessed by the corresponding handler.</p>
<p>You should not mess with the slots of these objects directly, but you
can subclass REQUEST in order to implement your own behaviour.  See
the REQUEST-CLASS slot of the ACCEPTOR class.</p>
<h4 id="acceptor">acceptor</h4>
<pre><code class="lisp">Initargs: :acceptor
Readers: hunchentoot:request-acceptor
</code></pre>

<p>The acceptor which created this request
 object.</p>
<h4 id="headers-in">headers-in</h4>
<pre><code class="lisp">Initargs: :headers-in
Readers: hunchentoot:headers-in
</code></pre>

<p>An alist of the incoming headers.</p>
<h4 id="method">method</h4>
<pre><code class="lisp">Initargs: :method
Readers: hunchentoot:request-method
</code></pre>

<p>The request method as a keyword.</p>
<h4 id="uri">uri</h4>
<pre><code class="lisp">Initargs: :uri
Readers: hunchentoot:request-uri
</code></pre>

<p>The request URI as a string.</p>
<h4 id="server-protocol">server-protocol</h4>
<pre><code class="lisp">Initargs: :server-protocol
Readers: hunchentoot:server-protocol
</code></pre>

<p>The HTTP protocol as a keyword.</p>
<h4 id="local-addr">local-addr</h4>
<pre><code class="lisp">Initargs: :local-addr
Readers: hunchentoot:local-addr
</code></pre>

<p>The IP address of the local system
 that the client connected to.</p>
<h4 id="local-port">local-port</h4>
<pre><code class="lisp">Initargs: :local-port
Readers: hunchentoot:local-port
</code></pre>

<p>The TCP port number of the local
 system that the client connected to.</p>
<h4 id="remote-addr">remote-addr</h4>
<pre><code class="lisp">Initargs: :remote-addr
Readers: hunchentoot:remote-addr
</code></pre>

<p>The IP address of the client that
 initiated this request.</p>
<h4 id="remote-port">remote-port</h4>
<pre><code class="lisp">Initargs: :remote-port
Readers: hunchentoot:remote-port
</code></pre>

<p>The TCP port number of the client
 socket from which this request originated.</p>
<h4 id="content-stream">content-stream</h4>
<pre><code class="lisp">Initargs: :content-stream
</code></pre>

<p>A stream from which the request
 body can be read if there is one.</p>
<h4 id="cookies-in">cookies-in</h4>
<pre><code class="lisp">Readers: hunchentoot:cookies-in
</code></pre>

<p>An alist of the cookies sent by the client.</p>
<h4 id="get-parameters">get-parameters</h4>
<pre><code class="lisp">Readers: hunchentoot:get-parameters
</code></pre>

<p>An alist of the GET parameters sent
 by the client.</p>
<h4 id="post-parameters">post-parameters</h4>
<pre><code class="lisp">Readers: hunchentoot:post-parameters
</code></pre>

<p>An alist of the POST parameters
 sent by the client.</p>
<h4 id="script-name">script-name</h4>
<pre><code class="lisp">Readers: hunchentoot:script-name
</code></pre>

<p>The URI requested by the client without
 the query string.</p>
<h4 id="query-string">query-string</h4>
<pre><code class="lisp">Readers: hunchentoot:query-string
</code></pre>

<p>The query string of this request.</p>
<h4 id="session">session</h4>
<pre><code class="lisp">Readers: hunchentoot:session
Writers: (setf hunchentoot:session)
</code></pre>

<p>The session object associated with this
 request.</p>
<h4 id="aux-data">aux-data</h4>
<p>Used to keep a user-modifiable alist with
 arbitrary data during the request.</p>
<h4 id="raw-post-data">raw-post-data</h4>
<p>The raw string sent as the body of a
 POST request, populated only if not a multipart/form-data request.</p>
<h3 id="8-session">8. SESSION</h3>
<pre><code class="lisp">Class
</code></pre>

<p>SESSION objects are automatically maintained by
Hunchentoot.  They should not be created explicitly with MAKE-INSTANCE
but implicitly with START-SESSION and they should be treated as opaque
objects.</p>
<p>You can ignore Hunchentoot's SESSION objects altogether and implement
your own sessions if you provide corresponding methods for
SESSION-COOKIE-VALUE and SESSION-VERIFY.</p>
<h4 id="session-id">session-id</h4>
<pre><code class="lisp">Type: integer
Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*))
Readers: hunchentoot:session-id
</code></pre>

<p>The unique ID (an INTEGER) of the session.</p>
<h4 id="session-string">session-string</h4>
<p>The session string encodes enough
 data to safely retrieve this session.  It is sent to the browser as a
 cookie value or as a GET parameter.</p>
<h4 id="user-agent">user-agent</h4>
<pre><code class="lisp">Initform: (hunchentoot:user-agent hunchentoot:*request*)
Readers: hunchentoot:session-user-agent
</code></pre>

<p>The incoming 'User-Agent' header that
 was sent when this session was created.</p>
<h4 id="remote-addr_1">remote-addr</h4>
<pre><code class="lisp">Initform: (hunchentoot:real-remote-addr hunchentoot:*request*)
Readers: hunchentoot:session-remote-addr
</code></pre>

<p>The remote IP address of the client
 when this session was started as returned by REAL-REMOTE-ADDR.</p>
<h4 id="session-start">session-start</h4>
<pre><code class="lisp">Initform: (GET-UNIVERSAL-TIME)
Readers: hunchentoot:session-start
</code></pre>

<p>The time this session was started.</p>
<h4 id="last-click">last-click</h4>
<p>The last time this session was used.</p>
<h4 id="session-data">session-data</h4>
<pre><code class="lisp">Initargs: :session-data
</code></pre>

<p>Data associated with this session -
 see SESSION-VALUE.</p>
<h4 id="max-time">max-time</h4>
<pre><code class="lisp">Type: fixnum
Initargs: :max-time
Initform: hunchentoot:*session-max-time*
Readers: hunchentoot:session-max-time
Writers: (setf hunchentoot:session-max-time)
</code></pre>

<p>The time (in seconds) after which this
 session expires if it's not used.</p>
<h4 id="session-id_1">session-id</h4>
<pre><code class="lisp">Type: integer
Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*))
Readers: hunchentoot:session-id
</code></pre>

<p>The unique ID (an INTEGER) of the session.</p>
<h4 id="session-string_1">session-string</h4>
<p>The session string encodes enough
 data to safely retrieve this session.  It is sent to the browser as a
 cookie value or as a GET parameter.</p>
<h4 id="user-agent_1">user-agent</h4>
<pre><code class="lisp">Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*)
Readers: hunchentoot:session-user-agent
</code></pre>

<p>The incoming 'User-Agent' header that
 was sent when this session was created.</p>
<h4 id="remote-addr_2">remote-addr</h4>
<pre><code class="lisp">Initform: (hunchentoot:real-remote-addr hunchentoot:*request*)
Readers: hunchentoot:session-remote-addr
</code></pre>

<p>The remote IP address of the client
 when this session was started as returned by REAL-REMOTE-ADDR.</p>
<h4 id="session-start_1">session-start</h4>
<pre><code class="lisp">Initform: (get-universal-time)
Readers: hunchentoot:session-start
</code></pre>

<p>The time this session was started.</p>
<h3 id="9-miscellaneous-functions">9. MISCELLANEOUS FUNCTIONS</h3>
<h4 id="aux-request-value">aux-request-value</h4>
<pre><code class="lisp">Function: (aux-request-value symbol &amp;optional (request *request*))
</code></pre>

<p>Returns the value associated with SYMBOL from the request object
REQUEST (the default is the current request) if it exists.  The
second return value is true if such a value was found.
Sets the value associated with SYMBOL from the request object
REQUEST (default is *REQUEST*).  If there is already a value
associated with SYMBOL it will be replaced.</p>
<h4 id="bad-request">bad-request</h4>
<pre><code class="lisp">Class
</code></pre>

<h4 id="client-as-string">client-as-string</h4>
<pre><code class="lisp">Function: (client-as-string socket)
</code></pre>

<p>A helper function which returns the client's address and port as a
   string and tries to act robustly in the presence of network problems.</p>
<h4 id="content-length_1">content-length*</h4>
<pre><code class="lisp">Function: (content-length* &amp;optional (reply *reply*))
</code></pre>

<p>The outgoing 'Content-Length' http header of REPLY.</p>
<h4 id="content-type_1">content-type*</h4>
<pre><code class="lisp">Function: (content-type* &amp;optional (reply *reply*))
</code></pre>

<p>The outgoing 'Content-Type' http header of REPLY.</p>
<h4 id="cookie-out">cookie-out</h4>
<pre><code class="lisp">Function: (cookie-out name &amp;optional (reply *reply*))
</code></pre>

<p>Returns the current value of the outgoing cookie named
NAME. Search is case-sensitive.</p>
<h4 id="cookie-in">cookie-in</h4>
<pre><code class="lisp">Function: (cookie-in name &amp;optional (request *request*))
</code></pre>

<p>Returns the cookie with the name NAME (a string) as sent by the
browser - or NIL if there is none.</p>
<h4 id="cookies-in_1">cookies-in*</h4>
<pre><code class="lisp">Function: (cookies-in* &amp;optional (request *request*))
</code></pre>

<p>Returns an alist of all cookies associated with the REQUEST object
REQUEST.</p>
<h4 id="cookies-out_1">cookies-out*</h4>
<pre><code class="lisp">Function: (cookies-out* &amp;optional (reply *reply*))
</code></pre>

<p>Returns an alist of the outgoing cookies associated with the
REPLY object REPLY.</p>
<h4 id="create-folder-dispatcher-and-handler">create-folder-dispatcher-and-handler</h4>
<pre><code class="lisp">Function: (create-folder-dispatcher-and-handler uri-prefix base-path &amp;optional content-type)
</code></pre>

<p>Creates and returns a dispatch function which will dispatch to a
handler function which emits the file relative to BASE-PATH that is
denoted by the URI of the request relative to URI-PREFIX.  URI-PREFIX
must be a string ending with a slash, BASE-PATH must be a pathname
designator for an existing directory.  If CONTENT-TYPE is not NIL,
it'll be the content type used for all files in the folder.</p>
<h4 id="create-prefix-dispatcher">create-prefix-dispatcher</h4>
<pre><code class="lisp">Function: (create-prefix-dispatcher prefix handler)
</code></pre>

<p>Creates a request dispatch function which will dispatch to the
function denoted by HANDLER if the file name of the current request
starts with the string PREFIX.</p>
<h4 id="create-regex-dispatcher">create-regex-dispatcher</h4>
<pre><code class="lisp">Function: (create-regex-dispatcher regex handler)
</code></pre>

<p>Creates a request dispatch function which will dispatch to the
function denoted by HANDLER if the file name of the current request
matches the CL-PPCRE regular expression REGEX.</p>
<h4 id="create-request-handler-thread">create-request-handler-thread</h4>
<pre><code class="lisp">Function: (create-request-handler-thread taskmaster socket)
</code></pre>

<p>Create a new thread in which to process the request.
    This thread will call PROCESS-CONNECTION to process the request.</p>
<h4 id="create-static-file-dispatcher-and-handler">create-static-file-dispatcher-and-handler</h4>
<pre><code class="lisp">Function: (create-static-file-dispatcher-and-handler uri path &amp;optional content-type)
</code></pre>

<p>Creates and returns a request dispatch function which will dispatch
to a handler function which emits the file denoted by the pathname
designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of
the request matches the string URI.  If CONTENT-TYPE is NIL, tries to
determine the content type via the file's suffix.</p>
<h4 id="decrement-taskmaster-thread-count">decrement-taskmaster-thread-count</h4>
<pre><code class="lisp">Function: (decrement-taskmaster-thread-count taskmaster)
</code></pre>

<p>Atomically decrement the number of taskmaster requests</p>
<h4 id="default-document-directory">default-document-directory</h4>
<pre><code class="lisp">Function: (default-document-directory &amp;optional sub-directory)
</code></pre>

<h4 id="delete-aux-request-value">delete-aux-request-value</h4>
<pre><code class="lisp">Function: (delete-aux-request-value symbol &amp;optional (request *request*))
</code></pre>

<p>Removes the value associated with SYMBOL from the request object
REQUEST.</p>
<h4 id="delete-session-value">delete-session-value</h4>
<pre><code class="lisp">Function: (delete-session-value symbol &amp;optional (session *session*))
</code></pre>

<p>Removes the value associated with SYMBOL from SESSION if there is
one.</p>
<h4 id="detach-socket">detach-socket</h4>
<pre><code class="lisp">Function: (detach-socket acceptor)
</code></pre>

<p>Indicate to Hunchentoot that it should stop serving
                   requests on the current request's socket.
                   Hunchentoot will finish processing the current
                   request and then return from PROCESS-CONNECTION
                   without closing the connection to the client.
                   DETACH-SOCKET can only be called from within a
                   request handler function.</p>
<h4 id="dispatch-easy-handlers">dispatch-easy-handlers</h4>
<pre><code class="lisp">Function: (dispatch-easy-handlers request)
</code></pre>

<p>This is a dispatcher which returns the appropriate handler
defined with DEFINE-EASY-HANDLER, if there is one.</p>
<h4 id="escape-for-html">escape-for-html</h4>
<pre><code class="lisp">Function: (escape-for-html string)
</code></pre>

<p>Escapes the characters #\&lt;, #>, #\', #\", and #\&amp; for HTML
output.</p>
<h4 id="execute-acceptor">execute-acceptor</h4>
<pre><code class="lisp">Function: (execute-acceptor taskmaster)
</code></pre>

<p>This is a callback called by the acceptor once it
has performed all initial processing to start listening for incoming
connections (see START-LISTENING).  It usually calls the
ACCEPT-CONNECTIONS method of the acceptor, but depending on the
taskmaster instance the method might be called from a new thread.</p>
<h4 id="get-parameter">get-parameter</h4>
<pre><code class="lisp">Function: (get-parameter name &amp;optional (request *request*))
</code></pre>

<p>Returns the GET parameter with name NAME (a string) - or NIL if
there is none.  Search is case-sensitive.</p>
<h4 id="get-parameters_1">get-parameters*</h4>
<pre><code class="lisp">Function: (get-parameters* &amp;optional (request *request*))
</code></pre>

<p>Returns an alist of the GET parameters associated with the REQUEST
object REQUEST.</p>
<h4 id="handle-if-modified-since">handle-if-modified-since</h4>
<pre><code class="lisp">Function: (handle-if-modified-since time &amp;optional (request *request*))
</code></pre>

<p>Handles the 'If-Modified-Since' header of REQUEST.  The date string
is compared to the one generated from the supplied universal time
TIME.</p>
<h4 id="handle-incoming-connection">handle-incoming-connection</h4>
<pre><code class="lisp">Function: (handle-incoming-connection taskmaster socket)
</code></pre>

<p>This function is called by the acceptor to start
processing of requests on a new incoming connection.  SOCKET is the
usocket instance that represents the new connection (or a socket
handle on LispWorks).  The taskmaster starts processing requests on
the incoming connection by calling the PROCESS-CONNECTION method of
the acceptor instance.  The SOCKET argument is passed to
PROCESS-CONNECTION as an argument.</p>
<h4 id="handle-request">handle-request</h4>
<pre><code class="lisp">Function: (handle-request acceptor request)
</code></pre>

<p>This function is called once the request has been
read and a REQUEST object has been created.  Its job is to set up
standard error handling and request logging.</p>
<p>Might be a good place for around methods specialized for your subclass
of ACCEPTOR which bind or rebind special variables which can then be
accessed by your handlers.</p>
<h4 id="handle-static-file">handle-static-file</h4>
<pre><code class="lisp">Function: (handle-static-file pathname &amp;optional content-type)
</code></pre>

<p>A function which acts like a Hunchentoot handler for the file
denoted by PATHNAME.  Sends a content type header corresponding to
CONTENT-TYPE or (if that is NIL) tries to determine the content type
via the file's suffix.</p>
<h4 id="header-in">header-in</h4>
<pre><code class="lisp">Function: (header-in name request)
</code></pre>

<p>Returns the incoming header with name NAME.  NAME
can be a keyword (recommended) or a string.</p>
<h4 id="header-in_1">header-in*</h4>
<pre><code class="lisp">Function: (header-in* name &amp;optional (request *request*))
</code></pre>

<p>Returns the incoming header with name NAME.  NAME can be a keyword
(recommended) or a string.</p>
<h4 id="headers-in_1">headers-in*</h4>
<pre><code class="lisp">Function: (headers-in* &amp;optional (request *request*))
</code></pre>

<p>Returns an alist of the incoming headers associated with the
REQUEST object REQUEST.</p>
<h4 id="headers-out_1">headers-out*</h4>
<pre><code class="lisp">Function: (headers-out* &amp;optional (reply *reply*))
</code></pre>

<p>Returns an alist of the outgoing headers associated with the
REPLY object REPLY.</p>
<h4 id="host">host</h4>
<pre><code class="lisp">Function: (host &amp;optional (request *request*))
</code></pre>

<p>Returns the 'Host' incoming http header value.</p>
<h4 id="http-token-p">http-token-p</h4>
<pre><code class="lisp">Function: (http-token-p token)
</code></pre>

<p>This function tests whether OBJECT is a non-empty string which is a
TOKEN according to RFC 2068 (i.e. whether it may be used for, say,
cookie names).</p>
<h4 id="hunchentoot-error">hunchentoot-error</h4>
<pre><code class="lisp">Function: (hunchentoot-error format-control &amp;rest format-arguments)
</code></pre>

<p>Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided
format control and arguments.
Superclass for all errors related to Hunchentoot.</p>
<h4 id="increment-taskmaster-thread-count">increment-taskmaster-thread-count</h4>
<pre><code class="lisp">Function: (increment-taskmaster-thread-count taskmaster)
</code></pre>

<p>Atomically increment the number of taskmaster requests.</p>
<h4 id="initialize-connection-stream">initialize-connection-stream</h4>
<pre><code class="lisp">Function: (initialize-connection-stream acceptor stream)
</code></pre>

<p>Can be used to modify the stream which is used to
communicate between client and server before the request is read.  The
default method of ACCEPTOR does nothing, but see for example the
method defined for SSL-ACCEPTOR.  All methods of this generic function
must return the stream to use.</p>
<h4 id="local-addr_1">local-addr*</h4>
<pre><code class="lisp">Function: (local-addr* &amp;optional (request *request*))
</code></pre>

<p>Returns the address the current request connected to.</p>
<h4 id="local-port_1">local-port*</h4>
<pre><code class="lisp">Function: (local-port* &amp;optional (request *request*))
</code></pre>

<p>Returns the port the current request connected to.</p>
<h4 id="log-message">log-message*</h4>
<pre><code class="lisp">Function: (log-message* log-level format-string &amp;rest format-arguments)
</code></pre>

<p>Convenience function which calls the message logger of the current
acceptor (if there is one) with the same arguments it accepts.</p>
<p>This is the function which Hunchentoot itself uses to log errors it
catches during request processing.</p>
<h4 id="maybe-invoke-debugger">maybe-invoke-debugger</h4>
<pre><code class="lisp">Function: (maybe-invoke-debugger condition)
</code></pre>

<p>This generic function is called whenever a
condition CONDITION is signaled in Hunchentoot.  You might want to
specialize it on specific condition classes for debugging purposes.</p>
<h4 id="mime-type">mime-type</h4>
<pre><code class="lisp">Function: (mime-type pathspec)
</code></pre>

<p>Given a pathname designator PATHSPEC returns the MIME type
(as a string) corresponding to the suffix of the file denoted by
PATHSPEC (or NIL).</p>
<h4 id="multi-threaded-taskmaster">multi-threaded-taskmaster</h4>
<p>An abstract class for taskmasters that use multiple threads.
For a concrete class to instantiate, use one-thread-per-connection-taskmaster.</p>
<h4 id="next-session-id">next-session-id</h4>
<pre><code class="lisp">Function: (next-session-id acceptor)
</code></pre>

<p>Returns the next sequential session ID, an integer,
which should be unique per session.  The default method uses a simple
global counter and isn't guarded by a lock.  For a high-performance
production environment you might consider using a more robust
implementation.</p>
<h4 id="no-cache">no-cache</h4>
<pre><code class="lisp">Function: (no-cache)
</code></pre>

<p>Adds appropriate headers to completely prevent caching on most browsers.</p>
<h4 id="one-thread-per-connection-taskmaster">one-thread-per-connection-taskmaster</h4>
<p>A taskmaster that starts one thread for listening
to incoming requests and one new thread for each incoming connection.</p>
<p>If MAX-THREAD-COUNT is null, a new thread will always be created for
each request.</p>
<p>If MAX-THREAD-COUNT is supplied, the number of request threads is
limited to that.  Furthermore, if MAX-ACCEPT-COUNT is not supplied, an
HTTP 503 will be sent if the thread limit is exceeded.  Otherwise, if
MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT;
in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only
then is HTTP 503 sent.</p>
<p>It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior
described above is racing with the acceptor listen backlog. If we are receiving
requests faster than threads can be spawned and 503 sent, the requests will be
silently rejected by the kernel.</p>
<p>In a load-balanced environment with multiple Hunchentoot servers, it's
reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null.
This will immediately result in HTTP 503 when one server is out of
resources, so the load balancer can try to find another server.</p>
<p>In an environment with a single Hunchentoot server, it's reasonable
to provide both MAX-THREAD-COUNT and a somewhat larger value for
MAX-ACCEPT-COUNT.  This will cause a server that's almost out of
resources to wait a bit; if the server is completely out of resources,
then the reply will be HTTP 503.</p>
<p>This is the default taskmaster implementation for multi-threaded Lisp
implementations.</p>
<h4 id="parameter">parameter</h4>
<pre><code class="lisp">Function: (parameter name &amp;optional (request *request*))
</code></pre>

<p>Returns the GET or the POST parameter with name NAME (a string) -
or NIL if there is none.  If both a GET and a POST parameter with the
same name exist the GET parameter is returned.  Search is
case-sensitive.</p>
<h4 id="parameter-error">parameter-error</h4>
<pre><code class="lisp">Function: (parameter-error format-control &amp;rest format-arguments)
</code></pre>

<p>Signals an error of type PARAMETER-ERROR with the provided
format control and arguments.
Signalled if a function was called with incosistent or illegal parameters.</p>
<h4 id="post-parameter">post-parameter</h4>
<pre><code class="lisp">Function: (post-parameter name &amp;optional (request *request*))
</code></pre>

<p>Returns the POST parameter with name NAME (a string) - or NIL if
there is none.  Search is case-sensitive.</p>
<h4 id="post-parameters_1">post-parameters*</h4>
<pre><code class="lisp">Function: (post-parameters* &amp;optional (request *request*))
</code></pre>

<p>Returns an alist of the POST parameters associated with the REQUEST
object REQUEST.</p>
<h4 id="process-connection">process-connection</h4>
<pre><code class="lisp">Function: (process-connection acceptor socket)
</code></pre>

<p>This function is called by the taskmaster when a
new client connection has been established.  Its arguments are the
ACCEPTOR object and a LispWorks socket handle or a usocket socket
stream object in SOCKET.  It reads the request headers, sets up the
request and reply objects, and hands over to PROCESS-REQUEST.  This is
done in a loop until the stream has to be closed or until a connection
timeout occurs.</p>
<p>It is probably not a good idea to re-implement this method until you
really, really know what you're doing.</p>
<h4 id="process-request">process-request</h4>
<pre><code class="lisp">Function: (process-request request)
</code></pre>

<p>This function is called by PROCESS-CONNECTION after
the incoming headers have been read.  It calls HANDLE-REQUEST to
select and call a handler and sends the output of this handler to the
client using START-OUTPUT.  Note that PROCESS-CONNECTION is called
once per connection and loops in case of a persistent connection while
PROCESS-REQUEST is called anew for each request.</p>
<p>Essentially, you can view process-request as a thin wrapper around
HANDLE-REQUEST.</p>
<p>The return value of this function is ignored.</p>
<h4 id="query-string_1">query-string*</h4>
<pre><code class="lisp">Function: (query-string* &amp;optional (request *request*))
</code></pre>

<p>Returns the query string of the REQUEST object REQUEST. That's
the part behind the question mark (i.e. the GET parameters).</p>
<h4 id="raw-post-data_1">raw-post-data</h4>
<pre><code class="lisp">Function: (raw-post-data &amp;key (request *request*) external-format force-text force-binary want-stream)
</code></pre>

<p>Returns the content sent by the client if there was any (unless
the content type was "multipart/form-data").  By default, the result
is a string if the type of the <code>Content-Type' media type is "text",
and a vector of octets otherwise.  In the case of a string, the
external format to be used to decode the content will be determined
from the</code>charset' parameter sent by the client (or otherwise
*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used).</p>
<p>You can also provide an external format explicitly (through
EXTERNAL-FORMAT) in which case the result will unconditionally be a
string.  Likewise, you can provide a true value for FORCE-TEXT which
will force Hunchentoot to act as if the type of the media type had
been "text".  Or you can provide a true value for FORCE-BINARY which
means that you want a vector of octets at any rate.</p>
<p>If, however, you provide a true value for WANT-STREAM, the other
parameters are ignored and you'll get the content (flexi) stream to
read from it yourself.  It is then your responsibility to read the
correct amount of data, because otherwise you won't be able to return
a response to the client.  If the content type of the request was
<code>multipart/form-data' or</code>application/x-www-form-urlencoded', the
content has been read by Hunchentoot already and you can't read from
the stream anymore.</p>
<p>You can call RAW-POST-DATA more than once per request, but you can't
mix calls which have different values for WANT-STREAM.</p>
<p>Note that this function is slightly misnamed because a client can send
content even if the request method is not POST.</p>
<h4 id="real-remote-addr">real-remote-addr</h4>
<pre><code class="lisp">Function: (real-remote-addr &amp;optional (request *request*))
</code></pre>

<p>Returns the 'X-Forwarded-For' incoming http header as the
second value in the form of a list of IP addresses and the first
element of this list as the first value if this header exists.
Otherwise returns the value of REMOTE-ADDR as the only value.</p>
<h4 id="reason-phrase">reason-phrase</h4>
<pre><code class="lisp">Function: (reason-phrase return-code)
</code></pre>

<p>Returns a reason phrase for the HTTP return code RETURN-CODE (which
should be an integer) or NIL for return codes Hunchentoot doesn't know.</p>
<h4 id="recompute-request-parameters">recompute-request-parameters</h4>
<pre><code class="lisp">Function: (recompute-request-parameters &amp;key (request *request*) (external-format
                                                                  *hunchentoot-default-external-format*))
</code></pre>

<p>Recomputes the GET and POST parameters for the REQUEST object
REQUEST.  This only makes sense if you're switching external formats
during the request.</p>
<h4 id="redirect">redirect</h4>
<pre><code class="lisp">Function: (redirect target &amp;key (host (host *request*) host-provided-p) port (protocol
                                                                              (if (ssl-p)
                                                                                  https
                                                                                  http)) (add-session-id
                                                                                          (not
                                                                                           (or
                                                                                            host-provided-p
                                                                                            (starts-with-scheme-p
                                                                                             target)
                                                                                            (cookie-in
                                                                                             (session-cookie-name
                                                                                              *acceptor*))))) (code
                                                                                                               +http-moved-temporarily+))
</code></pre>

<p>Redirects the browser to TARGET which should be a string.  If
TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL
are ignored.  Otherwise, TARGET should denote the path part of a URL,
PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to
redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET.
Adds a session ID if ADD-SESSION-ID is true.  If CODE is a 3xx
redirection code, it will be sent as status code.</p>
<h4 id="referer">referer</h4>
<pre><code class="lisp">Function: (referer &amp;optional (request *request*))
</code></pre>

<p>Returns the 'Referer' (sic!) http header.</p>
<h4 id="regenerate-session-cookie-value">regenerate-session-cookie-value</h4>
<pre><code class="lisp">Function: (regenerate-session-cookie-value session)
</code></pre>

<p>Regenerates the cookie value. This should be used
when a user logs in according to the application to prevent against
session fixation attacks. The cookie value being dependent on ID,
USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value
we can change is START to regenerate a new value. Since we're
generating a new cookie, it makes sense to have the session being
restarted, in time. That said, because of this fact, calling this
function twice in the same second will regenerate twice the same value.</p>
<h4 id="remote-addr_3">remote-addr*</h4>
<pre><code class="lisp">Function: (remote-addr* &amp;optional (request *request*))
</code></pre>

<p>Returns the address the current request originated from.</p>
<h4 id="remote-port_1">remote-port*</h4>
<pre><code class="lisp">Function: (remote-port* &amp;optional (request *request*))
</code></pre>

<p>Returns the port the current request originated from.</p>
<h4 id="remove-session">remove-session</h4>
<pre><code class="lisp">Function: (remove-session session)
</code></pre>

<p>Completely removes the SESSION object SESSION from Hunchentoot's
internal session database.</p>
<h4 id="reply-external-format_1">reply-external-format*</h4>
<pre><code class="lisp">Function: (reply-external-format* &amp;optional (reply *reply*))
</code></pre>

<p>The external format of REPLY which is used for character output.</p>
<h4 id="request-method">request-method*</h4>
<pre><code class="lisp">Function: (request-method* &amp;optional (request *request*))
</code></pre>

<p>Returns the request method as a Lisp keyword.</p>
<h4 id="request-pathname">request-pathname</h4>
<pre><code class="lisp">Function: (request-pathname &amp;optional (request *request*) drop-prefix)
</code></pre>

<p>Construct a relative pathname from the request's SCRIPT-NAME.
If DROP-PREFIX is given, pathname construction starts at the first path
segment after the prefix.</p>
<h4 id="request-uri">request-uri*</h4>
<pre><code class="lisp">Function: (request-uri* &amp;optional (request *request*))
</code></pre>

<p>Returns the request URI.</p>
<h4 id="require-authorization">require-authorization</h4>
<pre><code class="lisp">Function: (require-authorization &amp;optional (realm hunchentoot))
</code></pre>

<p>Sends back appropriate headers to require basic HTTP authentication
(see RFC 2617) for the realm REALM.</p>
<h4 id="reset-connection-stream">reset-connection-stream</h4>
<pre><code class="lisp">Function: (reset-connection-stream acceptor stream)
</code></pre>

<p>Resets the stream which is used to communicate
between client and server after one request has been served so that it
can be used to process the next request.  This generic function is
called after a request has been processed and must return the
stream.</p>
<h4 id="reset-session-secret">reset-session-secret</h4>
<pre><code class="lisp">Function: (reset-session-secret)
</code></pre>

<p>Sets *SESSION-SECRET* to a new random value. All old sessions will
cease to be valid.</p>
<h4 id="reset-sessions">reset-sessions</h4>
<pre><code class="lisp">Function: (reset-sessions &amp;optional (acceptor *acceptor*))
</code></pre>

<p>Removes ALL stored sessions of ACCEPTOR.</p>
<h4 id="return-code_1">return-code*</h4>
<pre><code class="lisp">Function: (return-code* &amp;optional (reply *reply*))
</code></pre>

<p>The http return code of REPLY.  The return codes Hunchentoot can
handle are defined in specials.lisp.</p>
<h4 id="rfc-1123-date">rfc-1123-date</h4>
<pre><code class="lisp">Function: (rfc-1123-date &amp;optional (time (get-universal-time)))
</code></pre>

<p>Generates a time string according to RFC 1123. Default is current time.
This can be used to send a 'Last-Modified' header - see
HANDLE-IF-MODIFIED-SINCE.</p>
<h4 id="script-name_1">script-name</h4>
<pre><code class="lisp">Function: (script-name object)
</code></pre>

<h4 id="script-name_2">script-name*</h4>
<pre><code class="lisp">Function: (script-name* &amp;optional (request *request*))
</code></pre>

<p>Returns the file name of the REQUEST object REQUEST. That's the
requested URI without the query string (i.e the GET parameters).</p>
<h4 id="send-headers">send-headers</h4>
<pre><code class="lisp">Function: (send-headers)
</code></pre>

<p>Sends the initial status line and all headers as determined by the
REPLY object *REPLY*.  Returns a binary stream to which the body of
the reply can be written.  Once this function has been called, further
changes to *REPLY* don't have any effect.  Also, automatic handling of
errors (i.e. sending the corresponding status code to the browser,
etc.) is turned off for this request.  If your handlers return the
full body as a string or as an array of octets you should NOT call
this function.</p>
<p>This function does not return control to the caller during HEAD
request processing.</p>
<h4 id="server-protocol_1">server-protocol</h4>
<pre><code class="lisp">Function: (server-protocol object)
</code></pre>

<h4 id="server-protocol_2">server-protocol*</h4>
<pre><code class="lisp">Function: (server-protocol* &amp;optional (request *request*))
</code></pre>

<p>Returns the request protocol as a Lisp keyword.</p>
<h4 id="session-cookie-name">session-cookie-name</h4>
<pre><code class="lisp">Function: (session-cookie-name acceptor)
</code></pre>

<p>Returns the name (a string) of the cookie (or the
GET parameter) which is used to store a session on the client side.
The default is to use the string "hunchentoot-session", but you can
specialize this function if you want another name.</p>
<h4 id="session-cookie-value">session-cookie-value</h4>
<pre><code class="lisp">Function: (session-cookie-value session)
</code></pre>

<p>Returns a string which can be used to safely
restore the session SESSION if as session has already been
established.  This is used as the value stored in the session cookie
or in the corresponding GET parameter and verified by SESSION-VERIFY.</p>
<p>A default method is provided and there's no reason to change it unless
you want to use your own session objects.</p>
<h4 id="session-created">session-created</h4>
<pre><code class="lisp">Function: (session-created acceptor new-session)
</code></pre>

<p>This function is called whenever a new session has
been created.  There's a default method which might trigger a session
GC based on the value of *SESSION-GC-FREQUENCY*.</p>
<p>The return value is ignored.</p>
<h4 id="session-db">session-db</h4>
<pre><code class="lisp">Function: (session-db acceptor)
</code></pre>

<p>Returns the current session database which is an
alist where each car is a session's ID and the cdr is the
corresponding SESSION object itself.  The default is to use a global
list for all acceptors.</p>
<h4 id="session-db-lock">session-db-lock</h4>
<pre><code class="lisp">Function: (session-db-lock acceptor &amp;key whole-db-p)
</code></pre>

<p>A function which returns a lock that will be used
to prevent concurrent access to sessions.  The first argument will be
the acceptor that handles the current request, the second argument is
true if the whole (current) session database is modified.  If it is
NIL, only one existing session in the database is modified.</p>
<p>This function can return NIL which means that sessions or session
databases will be modified without a lock held (for example for
single-threaded environments).  The default is to always return a
global lock (ignoring the ACCEPTOR argument) for Lisps that support
threads and NIL otherwise.</p>
<h4 id="session-gc">session-gc</h4>
<pre><code class="lisp">Function: (session-gc)
</code></pre>

<p>Removes sessions from the current session database which are too
old - see SESSION-TOO-OLD-P.</p>
<h4 id="session-start_2">session-start</h4>
<pre><code class="lisp">Function: (session-start object)
</code></pre>

<h4 id="session-too-old-p">session-too-old-p</h4>
<pre><code class="lisp">Function: (session-too-old-p session)
</code></pre>

<p>Returns true if the SESSION object SESSION has not been active in
the last (SESSION-MAX-TIME SESSION) seconds.</p>
<h4 id="session-value">session-value</h4>
<pre><code class="lisp">Function: (session-value symbol &amp;optional (session *session*))
</code></pre>

<p>Returns the value associated with SYMBOL from the session object
SESSION (the default is the current session) if it exists.
Sets the value associated with SYMBOL from the session object
SESSION. If there is already a value associated with SYMBOL it will be
replaced. Will automatically start a session if none was supplied and
there's no session for the current request.</p>
<h4 id="session-verify">session-verify</h4>
<pre><code class="lisp">Function: (session-verify request)
</code></pre>

<p>Tries to get a session identifier from the cookies
(or alternatively from the GET parameters) sent by the client (see
SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE).  This identifier is
then checked for validity against the REQUEST object REQUEST.  On
success the corresponding session object (if not too old) is returned
(and updated).  Otherwise NIL is returned.</p>
<p>A default method is provided and you only need to write your own one
if you want to maintain your own sessions.</p>
<h4 id="set-cookie">set-cookie</h4>
<pre><code class="lisp">Function: (set-cookie name &amp;key (value &quot;&quot;) expires max-age 
                             path domain secure http-only (reply *reply*))
</code></pre>

<p>Creates a cookie object from the parameters provided and adds
it to the outgoing cookies of the REPLY object REPLY. If a cookie
with the name NAME (case-sensitive) already exists, it is
replaced.</p>
<h4 id="set-cookie_1">set-cookie*</h4>
<pre><code class="lisp">Function: (set-cookie* cookie &amp;optional (reply *reply*))
</code></pre>

<p>Adds the COOKIE object COOKIE to the outgoing cookies of the
REPLY object REPLY. If a cookie with the same name
(case-sensitive) already exists, it is replaced.</p>
<h4 id="shutdown">shutdown</h4>
<pre><code class="lisp">Function: (shutdown taskmaster)
</code></pre>

<p>Shuts down the taskmaster, i.e. frees all resources
that were set up by it.  For example, a multi-threaded taskmaster
might terminate all threads that are currently associated with it.
This function is called by the acceptor's STOP method.</p>
<h4 id="single-threaded-taskmaster">single-threaded-taskmaster</h4>
<p>A taskmaster that runs synchronously in the thread
where the START function was invoked (or in the case of LispWorks in
the thread started by COMM:START-UP-SERVER).  This is the simplest
possible taskmaster implementation in that its methods do nothing but
calling their acceptor "sister" methods - EXECUTE-ACCEPTOR calls
ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls
PROCESS-CONNECTION.</p>
<h4 id="ssl-p">ssl-p</h4>
<pre><code class="lisp">Function: (ssl-p &amp;optional (acceptor *acceptor*))
</code></pre>

<p>Whether the current connection to the client is secure. See
ACCEPTOR-SSL-P.</p>
<h4 id="start">start</h4>
<pre><code class="lisp">Function: (start acceptor)
</code></pre>

<p>Starts the ACCEPTOR so that it begins accepting
connections.  Returns the acceptor.</p>
<h4 id="start-listening">start-listening</h4>
<pre><code class="lisp">Function: (start-listening acceptor)
</code></pre>

<p>Sets up a listen socket for the given ACCEPTOR and
enables it to listen to incoming connections.  This function is called
from the thread that starts the acceptor initially and may return
errors resulting from the listening operation (like 'address in use'
or similar).</p>
<h4 id="start-session">start-session</h4>
<pre><code class="lisp">Function: (start-session)
</code></pre>

<p>Returns the current SESSION object. If there is no current session,
creates one and updates the corresponding data structures. In this
case the function will also send a session cookie to the browser.</p>
<h4 id="start-thread">start-thread</h4>
<pre><code class="lisp">Function: (start-thread taskmaster thunk &amp;key name)
</code></pre>

<p>Start a name thread in which to call the THUNK, in the context of the given TASKMASTER.
Keyword arguments provide TASKMASTER-dependent options.
Return a thread object.</p>
<p>Hunchentoot taskmaster methods will call it with the taskmaster as the context,
allowing hunchentoot extensions to define specialized methods that may e.g.
wrap the thunk within a proper set of bindings and condition handlers.</p>
<h4 id="started-p">started-p</h4>
<pre><code class="lisp">Function: (started-p acceptor)
</code></pre>

<p>Tells if ACCEPTOR has been started.
The default implementation simply queries ACCEPTOR for its listening
status, so if T is returned to the calling thread, then some thread
has called START or some thread's call to STOP hasn't finished. If NIL
is returned either some thread has called STOP, or some thread's call
to START hasn't finished or START was never called at all for
ACCEPTOR.</p>
<h4 id="stop">stop</h4>
<pre><code class="lisp">Function: (stop acceptor &amp;key soft)
</code></pre>

<p>Stops the ACCEPTOR so that it no longer accepts
requests.  If SOFT is true, and there are any requests in progress,
wait until all requests are fully processed, but meanwhile do not
accept new requests.  Note that SOFT must not be set when calling
STOP from within a request handler, as that will deadlock.</p>
<h4 id="taskmaster-max-accept-count">taskmaster-max-accept-count</h4>
<pre><code class="lisp">Function: (taskmaster-max-accept-count taskmaster)
</code></pre>

<p>The maximum number of connections this taskmaster will accept before refusing
    new connections.  If supplied, this must be greater than MAX-THREAD-COUNT.
    The number of queued requests is the difference between MAX-ACCEPT-COUNT
    and MAX-THREAD-COUNT.</p>
<h4 id="taskmaster-max-thread-count">taskmaster-max-thread-count</h4>
<pre><code class="lisp">Function: (taskmaster-max-thread-count taskmaster)
</code></pre>

<p>The maximum number of request threads this taskmaster will simultaneously
    run before refusing or queueing new connections requests.  If the value
    is null, then there is no limit.</p>
<h4 id="taskmaster-thread-count">taskmaster-thread-count</h4>
<pre><code class="lisp">Function: (taskmaster-thread-count taskmaster)
</code></pre>

<p>Returns the current number of taskmaster requests.</p>
<h4 id="too-many-taskmaster-requests">too-many-taskmaster-requests</h4>
<pre><code class="lisp">Function: (too-many-taskmaster-requests taskmaster socket)
</code></pre>

<p>Signal a "too many requests" error, just prior to closing the connection.</p>
<h4 id="url-decode">url-decode</h4>
<pre><code class="lisp">Function: (url-decode string &amp;optional (external-format
                                        *hunchentoot-default-external-format*))
</code></pre>

<p>Decodes a URL-encoded string which is assumed to be encoded using the
external format EXTERNAL-FORMAT, i.e. this is the inverse of
URL-ENCODE. It is assumed that you'll rarely need this function, if
ever. But just in case - here it is. The default for EXTERNAL-FORMAT is
the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.</p>
<h4 id="url-encode">url-encode</h4>
<pre><code class="lisp">Function: (url-encode string &amp;optional (external-format
                                        *hunchentoot-default-external-format*))
</code></pre>

<p>URL-encodes a string using the external format EXTERNAL-FORMAT. The
default for EXTERNAL-FORMAT is the value of
*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.</p>
<h4 id="user-agent_2">user-agent</h4>
<pre><code class="lisp">Function: (user-agent &amp;optional (request *request*))
</code></pre>

<p>Returns the 'User-Agent' http header.</p>
<h4 id="within-request-p">within-request-p</h4>
<pre><code class="lisp">Function: (within-request-p)
</code></pre>

<p>True if we're in the context of a request, otherwise nil.</p>
<h3 id="10-configuration-variables">10. CONFIGURATION VARIABLES</h3>
<h4 id="catch-errors-p">*catch-errors-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Hunchentoot should catch and log errors (or rather invoke
the debugger).</p>
<h4 id="content-types-for-url-rewrite">*content-types-for-url-rewrite*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The content types for which url-rewriting is OK. See
*REWRITE-FOR-SESSION-URLS*.</p>
<h4 id="default-connection-timeout">*default-connection-timeout*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The default connection timeout used when an acceptor is reading
from and writing to a socket stream.</p>
<h4 id="default-content-type">*default-content-type*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The default content-type header which is returned to the client.
If this is text content type, the character set used for encoding the
response will automatically be added to the content type in a
``charset'' attribute.</p>
<h4 id="dispatch-table">*dispatch-table*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>A global list of dispatch functions.</p>
<h4 id="file-upload-hook">*file-upload-hook*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>If this is not NIL, it should be a unary function which will
be called with a pathname for each file which is uploaded to
Hunchentoot.  The pathname denotes the temporary file to which
the uploaded file is written.  The hook is called directly before
the file is created.</p>
<h4 id="handle-http-errors-p">*handle-http-errors-p*</h4>
<h4 id="header-stream">*header-stream*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>If this variable is not NIL, it should be bound to a stream to
which incoming and outgoing headers will be written for debugging
purposes.</p>
<h4 id="http-error-handler">*http-error-handler*</h4>
<h4 id="hunchentoot-default-external-format">*hunchentoot-default-external-format*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The external format used to compute the REQUEST object.</p>
<h4 id="hunchentoot-version">*hunchentoot-version*</h4>
<h4 id="lisp-errors-log-level">*lisp-errors-log-level*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Log level for Lisp errors.  Should be one of :ERROR (the default),
:WARNING, or :INFO.</p>
<h4 id="lisp-warnings-log-level">*lisp-warnings-log-level*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Log level for Lisp warnings.  Should be one of :ERROR, :WARNING
(the default), or :INFO.</p>
<h4 id="log-lisp-backtraces-p">*log-lisp-backtraces-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Lisp backtraces should be logged.  Only has an effect if
*LOG-LISP-ERRORS-P* is true as well.</p>
<h4 id="log-lisp-errors-p">*log-lisp-errors-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Lisp errors in request handlers should be logged.</p>
<h4 id="log-lisp-warnings-p">*log-lisp-warnings-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Lisp warnings in request handlers should be logged.</p>
<h4 id="methods-for-post-parameters">*methods-for-post-parameters*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>A list of the request method types (as keywords) for which
Hunchentoot will try to compute POST-PARAMETERS.</p>
<h4 id="rewrite-for-session-urls">*rewrite-for-session-urls*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether HTML pages should possibly be rewritten for cookie-less
session-management.</p>
<h4 id="session-gc-frequency">*session-gc-frequency*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>A session GC (see function SESSION-GC) will happen every
*SESSION-GC-FREQUENCY* requests (counting only requests which create
a new session) if this variable is not NIL.  See SESSION-CREATED.</p>
<h4 id="session-max-time">*session-max-time*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The default time (in seconds) after which a session times out.</p>
<h4 id="session-secret">*session-secret*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>A random ASCII string that's used to encode the public session
data.  This variable is initially unbound and will be set (using
RESET-SESSION-SECRET) the first time a session is created, if
necessary.  You can prevent this from happening if you set the value
yourself before starting acceptors.</p>
<h4 id="show-lisp-backtraces-p">*show-lisp-backtraces-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Lisp errors shown in HTML output should contain backtrace information.</p>
<h4 id="show-lisp-errors-p">*show-lisp-errors-p*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether Lisp errors in request handlers should be shown in HTML output.</p>
<h4 id="tmp-directory">*tmp-directory*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Directory for temporary files created by MAKE-TMP-FILE-NAME.</p>
<h4 id="use-remote-addr-for-sessions">*use-remote-addr-for-sessions*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether the client's remote IP (as returned by REAL-REMOTE-ADDR)
should be encoded into the session string.  If this value is true, a
session will cease to be accessible if the client's remote IP changes.</p>
<p>This might for example be an issue if the client uses a proxy server
which doesn't send correct 'X_FORWARDED_FOR' headers.</p>
<h4 id="use-user-agent-for-sessions">*use-user-agent-for-sessions*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>Whether the 'User-Agent' header should be encoded into the session
string.  If this value is true, a session will cease to be accessible
if the client sends a different 'User-Agent' header.</p>
<h3 id="11-variables-in-the-context-of-a-request">11. VARIABLES IN THE CONTEXT OF A REQUEST</h3>
<h4 id="acceptor_1">*acceptor*</h4>
<pre><code class="lisp">Variable

</code></pre>

<p>The current ACCEPTOR object.</p>
<h4 id="reply">*reply*</h4>
<pre><code class="lisp">Variable

</code></pre>

<p>The current REPLY object.</p>
<h4 id="request">*request*</h4>
<pre><code class="lisp">Variable

</code></pre>

<p>The current REQUEST object.</p>
<h4 id="session_1">*session*</h4>
<pre><code class="lisp">Variable
</code></pre>

<p>The current session while in the context of a request, or NIL.</p>
<h3 id="12-constants">12. CONSTANTS</h3>
<h4 id="http-accepted">+http-accepted+</h4>
<pre><code class="lisp">Constant: 202
</code></pre>

<p>HTTP return code (202) for 'Accepted'.</p>
<h4 id="http-authorization-required">+http-authorization-required+</h4>
<pre><code class="lisp">Constant: 401
</code></pre>

<p>HTTP return code (401) for 'Authorization Required'.</p>
<h4 id="http-bad-gateway">+http-bad-gateway+</h4>
<pre><code class="lisp">Constant: 502
</code></pre>

<p>HTTP return code (502) for 'Bad Gateway'.</p>
<h4 id="http-bad-request">+http-bad-request+</h4>
<pre><code class="lisp">Constant: 400
</code></pre>

<p>HTTP return code (400) for 'Bad Request'.</p>
<h4 id="http-conflict">+http-conflict+</h4>
<pre><code class="lisp">Constant: 409
</code></pre>

<p>HTTP return code (409) for 'Conflict'.</p>
<h4 id="http-continue">+http-continue+</h4>
<pre><code class="lisp">Constant: 100
</code></pre>

<p>HTTP return code (100) for 'Continue'.</p>
<h4 id="http-created">+http-created+</h4>
<pre><code class="lisp">Constant: 201
</code></pre>

<p>HTTP return code (201) for 'Created'.</p>
<h4 id="http-expectation-failed">+http-expectation-failed+</h4>
<pre><code class="lisp">Constant: 417
</code></pre>

<p>HTTP return code (417) for 'Expectation Failed'.</p>
<h4 id="http-failed-dependency">+http-failed-dependency+</h4>
<pre><code class="lisp">Constant: 424
</code></pre>

<p>HTTP return code (424) for 'Failed Dependency'.</p>
<h4 id="http-forbidden">+http-forbidden+</h4>
<pre><code class="lisp">Constant: 403
</code></pre>

<p>HTTP return code (403) for 'Forbidden'.</p>
<h4 id="http-gateway-time-out">+http-gateway-time-out+</h4>
<pre><code class="lisp">Constant: 504
</code></pre>

<p>HTTP return code (504) for 'Gateway Time-out'.</p>
<h4 id="http-gone">+http-gone+</h4>
<pre><code class="lisp">Constant: 410
</code></pre>

<p>HTTP return code (410) for 'Gone'.</p>
<h4 id="http-internal-server-error">+http-internal-server-error+</h4>
<pre><code class="lisp">Constant: 500
</code></pre>

<p>HTTP return code (500) for 'Internal Server Error'.</p>
<h4 id="http-length-required">+http-length-required+</h4>
<pre><code class="lisp">Constant: 411
</code></pre>

<p>HTTP return code (411) for 'Length Required'.</p>
<h4 id="http-method-not-allowed">+http-method-not-allowed+</h4>
<pre><code class="lisp">Constant: 405
</code></pre>

<p>HTTP return code (405) for 'Method Not Allowed'.</p>
<h4 id="http-moved-permanently">+http-moved-permanently+</h4>
<pre><code class="lisp">Constant: 301
</code></pre>

<p>HTTP return code (301) for 'Moved Permanently'.</p>
<h4 id="http-moved-temporarily">+http-moved-temporarily+</h4>
<pre><code class="lisp">Constant: 302
</code></pre>

<p>HTTP return code (302) for 'Moved Temporarily'.</p>
<h4 id="http-multi-status">+http-multi-status+</h4>
<pre><code class="lisp">Constant: 207
</code></pre>

<p>HTTP return code (207) for 'Multi-Status'.</p>
<h4 id="http-multiple-choices">+http-multiple-choices+</h4>
<pre><code class="lisp">Constant: 300
</code></pre>

<p>HTTP return code (300) for 'Multiple Choices'.</p>
<h4 id="http-network-authentication-required">+http-network-authentication-required+</h4>
<pre><code class="lisp">Constant: 511
</code></pre>

<p>HTTP return code (511) for 'Network Authentication Required'.</p>
<h4 id="http-no-content">+http-no-content+</h4>
<pre><code class="lisp">Constant: 204
</code></pre>

<p>HTTP return code (204) for 'No Content'.</p>
<h4 id="http-non-authoritative-information">+http-non-authoritative-information+</h4>
<pre><code class="lisp">Constant: 203
</code></pre>

<p>HTTP return code (203) for 'Non-Authoritative Information'.</p>
<h4 id="http-not-acceptable">+http-not-acceptable+</h4>
<pre><code class="lisp">Constant: 406
</code></pre>

<p>HTTP return code (406) for 'Not Acceptable'.</p>
<h4 id="http-not-found">+http-not-found+</h4>
<pre><code class="lisp">Constant: 404
</code></pre>

<p>HTTP return code (404) for 'Not Found'.</p>
<h4 id="http-not-implemented">+http-not-implemented+</h4>
<pre><code class="lisp">Constant: 501
</code></pre>

<p>HTTP return code (501) for 'Not Implemented'.</p>
<h4 id="http-not-modified">+http-not-modified+</h4>
<pre><code class="lisp">Constant: 304
</code></pre>

<p>HTTP return code (304) for 'Not Modified'.</p>
<h4 id="http-ok">+http-ok+</h4>
<pre><code class="lisp">Constant: 200
</code></pre>

<p>HTTP return code (200) for 'OK'.</p>
<h4 id="http-partial-content">+http-partial-content+</h4>
<pre><code class="lisp">Constant: 206
</code></pre>

<p>HTTP return code (206) for 'Partial Content'.</p>
<h4 id="http-payment-required">+http-payment-required+</h4>
<pre><code class="lisp">Constant: 402
</code></pre>

<p>HTTP return code (402) for 'Payment Required'.</p>
<h4 id="http-precondition-failed">+http-precondition-failed+</h4>
<pre><code class="lisp">Constant: 412
</code></pre>

<p>HTTP return code (412) for 'Precondition Failed'.</p>
<h4 id="http-precondition-required">+http-precondition-required+</h4>
<pre><code class="lisp">Constant: 428
</code></pre>

<p>HTTP return code (428) for 'Precondition Required'.</p>
<h4 id="http-proxy-authentication-required">+http-proxy-authentication-required+</h4>
<pre><code class="lisp">Constant: 407
</code></pre>

<p>HTTP return code (407) for 'Proxy Authentication Required'.</p>
<h4 id="http-request-entity-too-large">+http-request-entity-too-large+</h4>
<pre><code class="lisp">Constant: 413
</code></pre>

<p>HTTP return code (413) for 'Request Entity Too Large'.</p>
<h4 id="http-request-header-fields-too-large">+http-request-header-fields-too-large+</h4>
<pre><code class="lisp">Constant: 431
</code></pre>

<p>HTTP return code (431) for 'Request Header Fields Too Large'.</p>
<h4 id="http-request-time-out">+http-request-time-out+</h4>
<pre><code class="lisp">Constant: 408
</code></pre>

<p>HTTP return code (408) for 'Request Time-out'.</p>
<h4 id="http-request-uri-too-large">+http-request-uri-too-large+</h4>
<pre><code class="lisp">Constant: 414
</code></pre>

<p>HTTP return code (414) for 'Request-URI Too Large'.</p>
<h4 id="http-requested-range-not-satisfiable">+http-requested-range-not-satisfiable+</h4>
<pre><code class="lisp">Constant: 416
</code></pre>

<p>HTTP return code (416) for 'Requested range not satisfiable'.</p>
<h4 id="http-reset-content">+http-reset-content+</h4>
<pre><code class="lisp">Constant: 205
</code></pre>

<p>HTTP return code (205) for 'Reset Content'.</p>
<h4 id="http-see-other">+http-see-other+</h4>
<pre><code class="lisp">Constant: 303
</code></pre>

<p>HTTP return code (303) for 'See Other'.</p>
<h4 id="http-service-unavailable">+http-service-unavailable+</h4>
<pre><code class="lisp">Constant: 503
</code></pre>

<p>HTTP return code (503) for 'Service Unavailable'.</p>
<h4 id="http-switching-protocols">+http-switching-protocols+</h4>
<pre><code class="lisp">Constant: 101
</code></pre>

<p>HTTP return code (101) for 'Switching Protocols'.</p>
<h4 id="http-temporary-redirect">+http-temporary-redirect+</h4>
<pre><code class="lisp">Constant: 307
</code></pre>

<p>HTTP return code (307) for 'Temporary Redirect'.</p>
<h4 id="http-too-many-requests">+http-too-many-requests+</h4>
<pre><code class="lisp">Constant: 429
</code></pre>

<p>HTTP return code (429) for 'Too Many Requests'.</p>
<h4 id="http-unsupported-media-type">+http-unsupported-media-type+</h4>
<pre><code class="lisp">Constant: 415
</code></pre>

<p>HTTP return code (415) for 'Unsupported Media Type'.</p>
<h4 id="http-use-proxy">+http-use-proxy+</h4>
<pre><code class="lisp">Constant: 305
</code></pre>

<p>HTTP return code (305) for 'Use Proxy'.</p>
<h4 id="http-version-not-supported">+http-version-not-supported+</h4>
<pre><code class="lisp">Constant: 505
</code></pre>

<p>HTTP return code (505) for 'Version not supported'.</p>
<h3 id="13-hunchentoot-condition">13. HUNCHENTOOT-CONDITION</h3>
<pre><code class="lisp">Class
</code></pre>

<p>Superclass for all conditions related to Hunchentoot.</p>
<h3 id="14-hunchentoot-warning">14. HUNCHENTOOT-WARNING</h3>
<pre><code class="lisp">Class
</code></pre>

<p>Superclass for all warnings related to Hunchentoot.</p>
<h3 id="15-taskmaster">15. TASKMASTER</h3>
<pre><code class="lisp">Class
</code></pre>

<p>An instance of this class is responsible for
distributing the work of handling requests for its acceptor.  This is
an "abstract" class in the sense that usually only instances of
subclasses of TASKMASTER will be used.</p>
<h4 id="acceptor_2">acceptor</h4>
<pre><code class="lisp">Readers: hunchentoot:taskmaster-acceptor
Writers: (setf hunchentoot:taskmaster-acceptor)
</code></pre>

<p>A backpointer to the acceptor instance
 this taskmaster works for.</p>
<p>Decodes a URL-encoded string which is assumed to be encoded using the
external format EXTERNAL-FORMAT, i.e. this is the inverse of
URL-ENCODE. It is assumed that you'll rarely need this function, if
ever. But just in case - here it is. The default for EXTERNAL-FORMAT is
the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

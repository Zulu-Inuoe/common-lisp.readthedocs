{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"common-lisp.readthedocs Introduction Common Lisp documentation - libraries or the HyperSpec - isn't particularly \"modern\" or \"attractive\". Previous Efforts Documentation efforts have been made at: Quickdocs: I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. Quickref: Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. common-lisp.net: Ultimately, this seems to be the place for everything. CLiki: Again, layout and \"at a glance\"! UltraSpec: I liked this. The only trouble? It isn't \"quick\". UltraSpec I liked (the theme of) UltraSpec. I also liked mkdocs - that is what I am using here. What UltraSpec seems to be good for is more largish websites than what is here. And anyways, markdown files and dokuwiki files (which is what UltraSpec uses) are interconvertible (untested - to a fair extent perhaps?) using pandoc . (pandoc is also useful for a ton of other files!) mkdocs As a marketing for mkdocs: mkdocs is simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) mkdocs gh-deploy Done! Defacto Libraries Installation Each of the defacto libraries can be installed using quiclisp: (ql:quickload \"alexandria\") ; for example See quicklisp.org for instructions on installing quicklisp. Optionally, you may want to use sb-ext:add-package-local-nickname the packages for, well, adding package local nicknames . (sb-ext:add-package-local-nickname :a :alexandria) ; for SBCL Libraries documented so far (See the html version of this page , rather than the markdown version for the working links below.) alexandria bordeaux-threads hunchentoot","title":"index"},{"location":"#common-lispreadthedocs","text":"","title":"common-lisp.readthedocs"},{"location":"#introduction","text":"Common Lisp documentation - libraries or the HyperSpec - isn't particularly \"modern\" or \"attractive\".","title":"Introduction"},{"location":"#previous-efforts","text":"Documentation efforts have been made at: Quickdocs: I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. Quickref: Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. common-lisp.net: Ultimately, this seems to be the place for everything. CLiki: Again, layout and \"at a glance\"! UltraSpec: I liked this. The only trouble? It isn't \"quick\".","title":"Previous Efforts"},{"location":"#ultraspec","text":"I liked (the theme of) UltraSpec. I also liked mkdocs - that is what I am using here. What UltraSpec seems to be good for is more largish websites than what is here. And anyways, markdown files and dokuwiki files (which is what UltraSpec uses) are interconvertible (untested - to a fair extent perhaps?) using pandoc . (pandoc is also useful for a ton of other files!)","title":"UltraSpec"},{"location":"#mkdocs","text":"As a marketing for mkdocs: mkdocs is simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) mkdocs gh-deploy Done!","title":"mkdocs"},{"location":"#defacto-libraries","text":"","title":"Defacto Libraries"},{"location":"#installation","text":"Each of the defacto libraries can be installed using quiclisp: (ql:quickload \"alexandria\") ; for example See quicklisp.org for instructions on installing quicklisp. Optionally, you may want to use sb-ext:add-package-local-nickname the packages for, well, adding package local nicknames . (sb-ext:add-package-local-nickname :a :alexandria) ; for SBCL","title":"Installation"},{"location":"#libraries-documented-so-far","text":"(See the html version of this page , rather than the markdown version for the working links below.) alexandria bordeaux-threads hunchentoot","title":"Libraries documented so far"},{"location":"alexandria/","text":"Alexandria Manual - draft version Version: 1.0.0 (This documentation is modified to markdown from here on 01 March, 2020.) Alexandria Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 1. Hash Tables ensure-gethash Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table. copy-hash-table Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default. maphash-keys Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table . maphash-values Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table . hash-table-keys Function: (hash-table-keys table) Returns a list containing the keys of hash table table . hash-table-values Function: (hash-table-values table) Returns a list containing the values of hash table table . hash-table-alist Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table . hash-table-plist Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table . alist-hash-table Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs . plist-hash-table Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs . 2. Data and Control Flow define-constant Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value . destructuring-case Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error ensure-functionf Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function. multiple-value-prog2 Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form . named-lambda Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function. nth-value-or Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil . if-let Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect. when-let Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn . switch Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match. cswitch Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches. eswitch Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches. whichever Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random. xor Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value. disjoin Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned. conjoin Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate. compose Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned. multiple-value-compose Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last. curry Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function . rcurry Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function . 3. Conses proper-list Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error . circular-list Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error . appendf Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument. nconcf Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument. remove-from-plistf Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist . delete-from-plistf Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist . reversef Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place. nreversef Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place. unionf Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place. nunionf Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument. doplist Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values . circular-list-p Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise. circular-tree-p Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise. proper-list-p Function: (proper-list-p object) Returns true if object is a proper list. alist-plist Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order. plist-alist Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order. circular-list Function: (circular-list &rest elements) Creates a circular list of elements . make-circular-list Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element . ensure-car Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned. ensure-cons Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr. ensure-list Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list . flatten Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list. lastcar Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list. (setf Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list. proper-list-length Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list. mappend Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list. map-product Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6)) remove-from-plist Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq . delete-from-plist Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist. set-equal Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false. setp Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test . 4. Sequences proper-sequence Type designator for proper sequences, that is proper lists and sequences that are not lists. deletef Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords . removef Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords . rotate Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it. shuffle Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence. random-elt Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence . emptyp Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence. sequence-of-length-p Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists. length= Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer. copy-sequence Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence . first-elt Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence. (setf first-elt) Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence . last-elt Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence. (setf last-elt) Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence . starts-with Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. starts-with-subseq Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix . ends-with Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list. ends-with-subseq Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix . map-combinations Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function . map-derangements Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence . map-permutations Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence. 5. IO read-file-into-string Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector. 6. Macro Writing once-only Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1) with-gensyms Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to. with-unique-names Macro: (with-unique-names names &body forms) Alias for with-gensyms . featurep Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- . parse-body Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given. parse-ordinary-lambda-list Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed. 7. Symbols ensure-symbol Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external format-symbol Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package . make-keyword Function: (make-keyword name) Interns the string designated by name in the keyword package. make-gensym Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument. make-gensym-list Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument. symbolicate Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package. 8. Arrays array-index Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit . copy-array Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments. 9. Types string-designator A string designator type. A string designator is either a string, a symbol, or a character. coercef Macro: (coercef place type-spec env) Modify-macro for coerce . of-type Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type . type= Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent. 10. Numbers maxf Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers . minf Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers . binomial-coefficient Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k . count-permutations Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n clamp Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number . lerp Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v . factorial Function: (factorial n) Factorial of non-negative integer n . subfactorial Function: (subfactorial n) Subfactorial of the non-negative integer n . gaussian-random Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero. iota Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2) map-iota Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0 mean Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers. median Function: (median sample) Returns median of sample . sample must be a sequence of real numbers. variance Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers. standard-deviation Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"Alexandria Manual - draft version"},{"location":"alexandria/#alexandria-manual-draft-version","text":"Version: 1.0.0 (This documentation is modified to markdown from here on 01 March, 2020.)","title":"Alexandria Manual - draft version"},{"location":"alexandria/#alexandria","text":"Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Alexandria"},{"location":"alexandria/#1-hash-tables","text":"","title":"1. Hash Tables"},{"location":"alexandria/#ensure-gethash","text":"Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table.","title":"ensure-gethash"},{"location":"alexandria/#copy-hash-table","text":"Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default.","title":"copy-hash-table"},{"location":"alexandria/#maphash-keys","text":"Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table .","title":"maphash-keys"},{"location":"alexandria/#maphash-values","text":"Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table .","title":"maphash-values"},{"location":"alexandria/#hash-table-keys","text":"Function: (hash-table-keys table) Returns a list containing the keys of hash table table .","title":"hash-table-keys"},{"location":"alexandria/#hash-table-values","text":"Function: (hash-table-values table) Returns a list containing the values of hash table table .","title":"hash-table-values"},{"location":"alexandria/#hash-table-alist","text":"Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table .","title":"hash-table-alist"},{"location":"alexandria/#hash-table-plist","text":"Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table .","title":"hash-table-plist"},{"location":"alexandria/#alist-hash-table","text":"Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs .","title":"alist-hash-table"},{"location":"alexandria/#plist-hash-table","text":"Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs .","title":"plist-hash-table"},{"location":"alexandria/#2-data-and-control-flow","text":"","title":"2.  Data and Control Flow"},{"location":"alexandria/#define-constant","text":"Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value .","title":"define-constant"},{"location":"alexandria/#destructuring-case","text":"Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error","title":"destructuring-case"},{"location":"alexandria/#ensure-functionf","text":"Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function.","title":"ensure-functionf"},{"location":"alexandria/#multiple-value-prog2","text":"Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form .","title":"multiple-value-prog2"},{"location":"alexandria/#named-lambda","text":"Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function.","title":"named-lambda"},{"location":"alexandria/#nth-value-or","text":"Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil .","title":"nth-value-or"},{"location":"alexandria/#if-let","text":"Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect.","title":"if-let"},{"location":"alexandria/#when-let","text":"Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn .","title":"when-let"},{"location":"alexandria/#switch","text":"Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match.","title":"switch"},{"location":"alexandria/#cswitch","text":"Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches.","title":"cswitch"},{"location":"alexandria/#eswitch","text":"Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches.","title":"eswitch"},{"location":"alexandria/#whichever","text":"Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random.","title":"whichever"},{"location":"alexandria/#xor","text":"Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value.","title":"xor"},{"location":"alexandria/#disjoin","text":"Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned.","title":"disjoin"},{"location":"alexandria/#conjoin","text":"Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate.","title":"conjoin"},{"location":"alexandria/#compose","text":"Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned.","title":"compose"},{"location":"alexandria/#multiple-value-compose","text":"Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last.","title":"multiple-value-compose"},{"location":"alexandria/#curry","text":"Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function .","title":"curry"},{"location":"alexandria/#rcurry","text":"Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function .","title":"rcurry"},{"location":"alexandria/#3-conses","text":"","title":"3. Conses"},{"location":"alexandria/#proper-list","text":"Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error .","title":"proper-list"},{"location":"alexandria/#circular-list","text":"Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error .","title":"circular-list"},{"location":"alexandria/#appendf","text":"Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument.","title":"appendf"},{"location":"alexandria/#nconcf","text":"Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument.","title":"nconcf"},{"location":"alexandria/#remove-from-plistf","text":"Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist .","title":"remove-from-plistf"},{"location":"alexandria/#delete-from-plistf","text":"Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist .","title":"delete-from-plistf"},{"location":"alexandria/#reversef","text":"Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place.","title":"reversef"},{"location":"alexandria/#nreversef","text":"Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place.","title":"nreversef"},{"location":"alexandria/#unionf","text":"Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place.","title":"unionf"},{"location":"alexandria/#nunionf","text":"Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument.","title":"nunionf"},{"location":"alexandria/#doplist","text":"Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values .","title":"doplist"},{"location":"alexandria/#circular-list-p","text":"Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise.","title":"circular-list-p"},{"location":"alexandria/#circular-tree-p","text":"Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise.","title":"circular-tree-p"},{"location":"alexandria/#proper-list-p","text":"Function: (proper-list-p object) Returns true if object is a proper list.","title":"proper-list-p"},{"location":"alexandria/#alist-plist","text":"Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order.","title":"alist-plist"},{"location":"alexandria/#plist-alist","text":"Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order.","title":"plist-alist"},{"location":"alexandria/#circular-list_1","text":"Function: (circular-list &rest elements) Creates a circular list of elements .","title":"circular-list"},{"location":"alexandria/#make-circular-list","text":"Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element .","title":"make-circular-list"},{"location":"alexandria/#ensure-car","text":"Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned.","title":"ensure-car"},{"location":"alexandria/#ensure-cons","text":"Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr.","title":"ensure-cons"},{"location":"alexandria/#ensure-list","text":"Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list .","title":"ensure-list"},{"location":"alexandria/#flatten","text":"Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list.","title":"flatten"},{"location":"alexandria/#lastcar","text":"Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list.","title":"lastcar"},{"location":"alexandria/#setf","text":"Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list.","title":"(setf"},{"location":"alexandria/#proper-list-length","text":"Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list.","title":"proper-list-length"},{"location":"alexandria/#mappend","text":"Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list.","title":"mappend"},{"location":"alexandria/#map-product","text":"Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))","title":"map-product"},{"location":"alexandria/#remove-from-plist","text":"Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq .","title":"remove-from-plist"},{"location":"alexandria/#delete-from-plist","text":"Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist.","title":"delete-from-plist"},{"location":"alexandria/#set-equal","text":"Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false.","title":"set-equal"},{"location":"alexandria/#setp","text":"Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test .","title":"setp"},{"location":"alexandria/#4-sequences","text":"","title":"4. Sequences"},{"location":"alexandria/#proper-sequence","text":"Type designator for proper sequences, that is proper lists and sequences that are not lists.","title":"proper-sequence"},{"location":"alexandria/#deletef","text":"Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords .","title":"deletef"},{"location":"alexandria/#removef","text":"Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords .","title":"removef"},{"location":"alexandria/#rotate","text":"Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it.","title":"rotate"},{"location":"alexandria/#shuffle","text":"Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence.","title":"shuffle"},{"location":"alexandria/#random-elt","text":"Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence .","title":"random-elt"},{"location":"alexandria/#emptyp","text":"Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence.","title":"emptyp"},{"location":"alexandria/#sequence-of-length-p","text":"Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists.","title":"sequence-of-length-p"},{"location":"alexandria/#length","text":"Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer.","title":"length="},{"location":"alexandria/#copy-sequence","text":"Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence .","title":"copy-sequence"},{"location":"alexandria/#first-elt","text":"Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence.","title":"first-elt"},{"location":"alexandria/#setf-first-elt","text":"Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf first-elt)"},{"location":"alexandria/#last-elt","text":"Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence.","title":"last-elt"},{"location":"alexandria/#setf-last-elt","text":"Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf last-elt)"},{"location":"alexandria/#starts-with","text":"Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence.","title":"starts-with"},{"location":"alexandria/#starts-with-subseq","text":"Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix .","title":"starts-with-subseq"},{"location":"alexandria/#ends-with","text":"Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list.","title":"ends-with"},{"location":"alexandria/#ends-with-subseq","text":"Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix .","title":"ends-with-subseq"},{"location":"alexandria/#map-combinations","text":"Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function .","title":"map-combinations"},{"location":"alexandria/#map-derangements","text":"Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence .","title":"map-derangements"},{"location":"alexandria/#map-permutations","text":"Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence.","title":"map-permutations"},{"location":"alexandria/#5-io","text":"","title":"5. IO"},{"location":"alexandria/#read-file-into-string","text":"Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector.","title":"read-file-into-string"},{"location":"alexandria/#6-macro-writing","text":"","title":"6. Macro Writing"},{"location":"alexandria/#once-only","text":"Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1)","title":"once-only"},{"location":"alexandria/#with-gensyms","text":"Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to.","title":"with-gensyms"},{"location":"alexandria/#with-unique-names","text":"Macro: (with-unique-names names &body forms) Alias for with-gensyms .","title":"with-unique-names"},{"location":"alexandria/#featurep","text":"Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- .","title":"featurep"},{"location":"alexandria/#parse-body","text":"Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given.","title":"parse-body"},{"location":"alexandria/#parse-ordinary-lambda-list","text":"Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed.","title":"parse-ordinary-lambda-list"},{"location":"alexandria/#7-symbols","text":"","title":"7. Symbols"},{"location":"alexandria/#ensure-symbol","text":"Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external","title":"ensure-symbol"},{"location":"alexandria/#format-symbol","text":"Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package .","title":"format-symbol"},{"location":"alexandria/#make-keyword","text":"Function: (make-keyword name) Interns the string designated by name in the keyword package.","title":"make-keyword"},{"location":"alexandria/#make-gensym","text":"Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument.","title":"make-gensym"},{"location":"alexandria/#make-gensym-list","text":"Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument.","title":"make-gensym-list"},{"location":"alexandria/#symbolicate","text":"Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package.","title":"symbolicate"},{"location":"alexandria/#8-arrays","text":"","title":"8. Arrays"},{"location":"alexandria/#array-index","text":"Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit .","title":"array-index"},{"location":"alexandria/#copy-array","text":"Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments.","title":"copy-array"},{"location":"alexandria/#9-types","text":"","title":"9. Types"},{"location":"alexandria/#string-designator","text":"A string designator type. A string designator is either a string, a symbol, or a character.","title":"string-designator"},{"location":"alexandria/#coercef","text":"Macro: (coercef place type-spec env) Modify-macro for coerce .","title":"coercef"},{"location":"alexandria/#of-type","text":"Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type .","title":"of-type"},{"location":"alexandria/#type","text":"Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent.","title":"type="},{"location":"alexandria/#10-numbers","text":"","title":"10. Numbers"},{"location":"alexandria/#maxf","text":"Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers .","title":"maxf"},{"location":"alexandria/#minf","text":"Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers .","title":"minf"},{"location":"alexandria/#binomial-coefficient","text":"Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k .","title":"binomial-coefficient"},{"location":"alexandria/#count-permutations","text":"Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n","title":"count-permutations"},{"location":"alexandria/#clamp","text":"Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number .","title":"clamp"},{"location":"alexandria/#lerp","text":"Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v .","title":"lerp"},{"location":"alexandria/#factorial","text":"Function: (factorial n) Factorial of non-negative integer n .","title":"factorial"},{"location":"alexandria/#subfactorial","text":"Function: (subfactorial n) Subfactorial of the non-negative integer n .","title":"subfactorial"},{"location":"alexandria/#gaussian-random","text":"Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero.","title":"gaussian-random"},{"location":"alexandria/#iota","text":"Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2)","title":"iota"},{"location":"alexandria/#map-iota","text":"Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0","title":"map-iota"},{"location":"alexandria/#mean","text":"Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers.","title":"mean"},{"location":"alexandria/#median","text":"Function: (median sample) Returns median of sample . sample must be a sequence of real numbers.","title":"median"},{"location":"alexandria/#variance","text":"Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers.","title":"variance"},{"location":"alexandria/#standard-deviation","text":"Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"standard-deviation"},{"location":"bordeaux-threads/","text":"bordeaux-threads Version: 0.8.7 BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: 1) Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. 2) Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. 3) Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. 4) Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages. *default-special-bindings* This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to MAKE-THREAD to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list. *standard-io-bindings* Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX. *supports-threads-p* This should be set to T if the running instance has thread support. acquire-lock Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock LOCK for the calling thread. WAIT-P governs what happens if the lock is not available: if WAIT-P is true, the calling thread will wait until the lock is available and then acquire it; if WAIT-P is NIL, ACQUIRE-LOCK will return immediately. ACQUIRE-LOCK returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead MAKE-RECURSIVE-LOCK and friends. acquire-recursive-lock Function: (acquire-recursive-lock lock) As for ACQUIRE-LOCK, but for recursive locks. all-threads Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it. condition-notify Function: (condition-notify condition-variable) Notify at least one of the threads waiting for CONDITION-VARIABLE. It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. CONDITION-NOTIFY has no useful return value. In an implementation that does not support multiple threads, it has no effect. condition-wait Function: (condition-wait condition-variable lock &key timeout) Atomically release LOCK and enqueue the calling thread waiting for CONDITION-VARIABLE. The thread will resume when another thread has notified it using CONDITION-NOTIFY; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds LOCK. If TIMEOUT is nil or not provided, the system always reacquires LOCK before returning to the caller. In this case T is returned. If TIMEOUT is non-nil, the call will return after at most TIMEOUT seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of CONDITION-WAIT with TIMEOUT diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error. current-thread Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by MAKE-THREAD. destroy-thread Function: (destroy-thread thread) Terminates the thread THREAD, which is an object as returned by MAKE-THREAD. This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error. interrupt-thread Function: (interrupt-thread thread function &rest args) Interrupt THREAD and cause it to evaluate FUNCTION before continuing with the interrupted path of execution. This may not be a good idea if THREAD is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error. join-thread Function: (join-thread thread) Wait until THREAD terminates. If THREAD has already terminated, return immediately. The return values of the thread function are returned. lock lock-p Function: (lock-p object) Returns T if OBJECT is a lock; returns NIL otherwise. make-condition-variable Function: (make-condition-variable &key name) Returns a new condition-variable object for use with CONDITION-WAIT and CONDITION-NOTIFY. make-lock Function: (make-lock &optional name) Creates a lock (a mutex) whose name is NAME. If the system does not support multiple threads this will still return some object, but it may not be used for very much. make-recursive-lock Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is NAME. A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread. make-semaphore Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied NAME and initial counter value COUNT. make-thread Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named NAME, which will call the function FUNCTION with no arguments: when FUNCTION returns, the thread terminates. NAME defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, MAKE-THREAD will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by INITIAL-BINDINGS, are local to the thread they are introduced in, except that Local bindings in the the caller of MAKE-THREAD may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread. recursive-lock recursive-lock-p Function: (recursive-lock-p object) Returns T if OBJECT is a recursive lock; returns NIL otherwise. release-lock Function: (release-lock lock) Release LOCK. It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the ACQUIRE-LOCK call in one of them will now be able to continue. This function has no interesting return value. release-recursive-lock Function: (release-recursive-lock lock) Release the recursive LOCK. The lock will only become free after as many Release operations as there have been Acquire operations. See RELEASE-LOCK for other information. semaphore semaphore-p Function: (semaphore-p object) Returns T if OBJECT is a semaphore; returns NIL otherwise. signal-semaphore Function: (signal-semaphore semaphore &key (count 1)) Increment SEMAPHORE by COUNT. If there are threads waiting on this semaphore, then COUNT of them are woken up. start-multiprocessing Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly. thread thread-alive-p Function: (thread-alive-p thread) Returns true if THREAD is alive, that is, if DESTROY-THREAD has not been called on it. thread-name Function: (thread-name thread) Returns the name of the thread, as supplied to MAKE-THREAD. thread-yield Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing. threadp Function: (threadp object) Returns true if object is a thread, otherwise NIL. timeout wait-on-semaphore Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of SEMAPHORE by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If TIMEOUT is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count. with-lock-held Function: (with-lock-held (place) &body body) Evaluates BODY with the lock named by PLACE, the value of which is a lock created by MAKE-LOCK. Before the forms in BODY are evaluated, the lock is acquired as if by using ACQUIRE-LOCK. After the forms in BODY have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by RELEASE-LOCK. Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted. with-recursive-lock-held Function: (with-recursive-lock-held (place) &body body) Evaluates BODY with the recursive lock named by PLACE, which is a reference to a recursive lock created by MAKE-RECURSIVE-LOCK. See WITH-LOCK-HELD etc etc with-timeout Function: (with-timeout (timeout) &body body)","title":"bordeaux-threads"},{"location":"bordeaux-threads/#bordeaux-threads","text":"Version: 0.8.7 BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: 1) Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. 2) Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. 3) Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. 4) Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages.","title":"bordeaux-threads"},{"location":"bordeaux-threads/#default-special-bindings","text":"This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to MAKE-THREAD to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list.","title":"*default-special-bindings*"},{"location":"bordeaux-threads/#standard-io-bindings","text":"Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX.","title":"*standard-io-bindings*"},{"location":"bordeaux-threads/#supports-threads-p","text":"This should be set to T if the running instance has thread support.","title":"*supports-threads-p*"},{"location":"bordeaux-threads/#acquire-lock","text":"Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock LOCK for the calling thread. WAIT-P governs what happens if the lock is not available: if WAIT-P is true, the calling thread will wait until the lock is available and then acquire it; if WAIT-P is NIL, ACQUIRE-LOCK will return immediately. ACQUIRE-LOCK returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead MAKE-RECURSIVE-LOCK and friends.","title":"acquire-lock"},{"location":"bordeaux-threads/#acquire-recursive-lock","text":"Function: (acquire-recursive-lock lock) As for ACQUIRE-LOCK, but for recursive locks.","title":"acquire-recursive-lock"},{"location":"bordeaux-threads/#all-threads","text":"Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it.","title":"all-threads"},{"location":"bordeaux-threads/#condition-notify","text":"Function: (condition-notify condition-variable) Notify at least one of the threads waiting for CONDITION-VARIABLE. It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. CONDITION-NOTIFY has no useful return value. In an implementation that does not support multiple threads, it has no effect.","title":"condition-notify"},{"location":"bordeaux-threads/#condition-wait","text":"Function: (condition-wait condition-variable lock &key timeout) Atomically release LOCK and enqueue the calling thread waiting for CONDITION-VARIABLE. The thread will resume when another thread has notified it using CONDITION-NOTIFY; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds LOCK. If TIMEOUT is nil or not provided, the system always reacquires LOCK before returning to the caller. In this case T is returned. If TIMEOUT is non-nil, the call will return after at most TIMEOUT seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of CONDITION-WAIT with TIMEOUT diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error.","title":"condition-wait"},{"location":"bordeaux-threads/#current-thread","text":"Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by MAKE-THREAD.","title":"current-thread"},{"location":"bordeaux-threads/#destroy-thread","text":"Function: (destroy-thread thread) Terminates the thread THREAD, which is an object as returned by MAKE-THREAD. This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error.","title":"destroy-thread"},{"location":"bordeaux-threads/#interrupt-thread","text":"Function: (interrupt-thread thread function &rest args) Interrupt THREAD and cause it to evaluate FUNCTION before continuing with the interrupted path of execution. This may not be a good idea if THREAD is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error.","title":"interrupt-thread"},{"location":"bordeaux-threads/#join-thread","text":"Function: (join-thread thread) Wait until THREAD terminates. If THREAD has already terminated, return immediately. The return values of the thread function are returned.","title":"join-thread"},{"location":"bordeaux-threads/#lock","text":"","title":"lock"},{"location":"bordeaux-threads/#lock-p","text":"Function: (lock-p object) Returns T if OBJECT is a lock; returns NIL otherwise.","title":"lock-p"},{"location":"bordeaux-threads/#make-condition-variable","text":"Function: (make-condition-variable &key name) Returns a new condition-variable object for use with CONDITION-WAIT and CONDITION-NOTIFY.","title":"make-condition-variable"},{"location":"bordeaux-threads/#make-lock","text":"Function: (make-lock &optional name) Creates a lock (a mutex) whose name is NAME. If the system does not support multiple threads this will still return some object, but it may not be used for very much.","title":"make-lock"},{"location":"bordeaux-threads/#make-recursive-lock","text":"Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is NAME. A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.","title":"make-recursive-lock"},{"location":"bordeaux-threads/#make-semaphore","text":"Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied NAME and initial counter value COUNT.","title":"make-semaphore"},{"location":"bordeaux-threads/#make-thread","text":"Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named NAME, which will call the function FUNCTION with no arguments: when FUNCTION returns, the thread terminates. NAME defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, MAKE-THREAD will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by INITIAL-BINDINGS, are local to the thread they are introduced in, except that Local bindings in the the caller of MAKE-THREAD may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread.","title":"make-thread"},{"location":"bordeaux-threads/#recursive-lock","text":"","title":"recursive-lock"},{"location":"bordeaux-threads/#recursive-lock-p","text":"Function: (recursive-lock-p object) Returns T if OBJECT is a recursive lock; returns NIL otherwise.","title":"recursive-lock-p"},{"location":"bordeaux-threads/#release-lock","text":"Function: (release-lock lock) Release LOCK. It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the ACQUIRE-LOCK call in one of them will now be able to continue. This function has no interesting return value.","title":"release-lock"},{"location":"bordeaux-threads/#release-recursive-lock","text":"Function: (release-recursive-lock lock) Release the recursive LOCK. The lock will only become free after as many Release operations as there have been Acquire operations. See RELEASE-LOCK for other information.","title":"release-recursive-lock"},{"location":"bordeaux-threads/#semaphore","text":"","title":"semaphore"},{"location":"bordeaux-threads/#semaphore-p","text":"Function: (semaphore-p object) Returns T if OBJECT is a semaphore; returns NIL otherwise.","title":"semaphore-p"},{"location":"bordeaux-threads/#signal-semaphore","text":"Function: (signal-semaphore semaphore &key (count 1)) Increment SEMAPHORE by COUNT. If there are threads waiting on this semaphore, then COUNT of them are woken up.","title":"signal-semaphore"},{"location":"bordeaux-threads/#start-multiprocessing","text":"Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly.","title":"start-multiprocessing"},{"location":"bordeaux-threads/#thread","text":"","title":"thread"},{"location":"bordeaux-threads/#thread-alive-p","text":"Function: (thread-alive-p thread) Returns true if THREAD is alive, that is, if DESTROY-THREAD has not been called on it.","title":"thread-alive-p"},{"location":"bordeaux-threads/#thread-name","text":"Function: (thread-name thread) Returns the name of the thread, as supplied to MAKE-THREAD.","title":"thread-name"},{"location":"bordeaux-threads/#thread-yield","text":"Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing.","title":"thread-yield"},{"location":"bordeaux-threads/#threadp","text":"Function: (threadp object) Returns true if object is a thread, otherwise NIL.","title":"threadp"},{"location":"bordeaux-threads/#timeout","text":"","title":"timeout"},{"location":"bordeaux-threads/#wait-on-semaphore","text":"Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of SEMAPHORE by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If TIMEOUT is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count.","title":"wait-on-semaphore"},{"location":"bordeaux-threads/#with-lock-held","text":"Function: (with-lock-held (place) &body body) Evaluates BODY with the lock named by PLACE, the value of which is a lock created by MAKE-LOCK. Before the forms in BODY are evaluated, the lock is acquired as if by using ACQUIRE-LOCK. After the forms in BODY have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by RELEASE-LOCK. Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted.","title":"with-lock-held"},{"location":"bordeaux-threads/#with-recursive-lock-held","text":"Function: (with-recursive-lock-held (place) &body body) Evaluates BODY with the recursive lock named by PLACE, which is a reference to a recursive lock created by MAKE-RECURSIVE-LOCK. See WITH-LOCK-HELD etc etc","title":"with-recursive-lock-held"},{"location":"bordeaux-threads/#with-timeout","text":"Function: (with-timeout (timeout) &body body)","title":"with-timeout"},{"location":"hunchentoot.bak/","text":"hunchentoot - The Common Lisp web server (formerly TBNL) Version: 1.2.38 INTRODUCTION Hunchentoot is a web server written in Common Lisp and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . It currently works with LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Complete documentation for Hunchentoot including details about how to install it can be found in the docs directory or at the project website . Download and Installation (ql:quickload :hunchentoot) Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests. Without cl+ssl You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it. clbuild Hunchentoot and its dependencies can also be installed with clbuild . Gentoo Linux There's also a port for Gentoo Linux thanks to Matthew Kennedy. Running Hunchentoot on port 80 Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic. Hunchentoot behind a proxy If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache. Support The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first . MORE DOCUMENTATION, TUTORIALS AND ADD-ONS Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it. API REFERENCE 1. ACCEPTOR Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. port Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started. address Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default. name Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM. request-class Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST. reply-class Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY. HUNCHENTOOT:TASKMASTER Initargs: :taskmasterdocumentation: The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp. output-chunking-p Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL. input-chunking-p Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL. persistent-connections-p Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors. read-timeout Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. write-timeout Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. listen-socket The socket listening for incoming connections. listen-backlog Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections. acceptor-shutdown-p Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL. requests-in-progress Initform: 0 The number of requests currently in progress. shutdown-queue A condition variable used with soft shutdown, signaled when all requests have been processed. shutdown-lock The lock protecting the shutdown-queue condition variable and the requests-in-progress counter. access-log-destination Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. message-log-destination Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. error-template-directory Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response. document-root Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request.#### acceptor-access-log-destination 2. EASY-ACCEPTOR Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: HUNCHENTOOT:ACCEPTOR Direct subclasses: HUNCHENTOOT:EASY-SSL-ACCEPTOR 3. DEFINE-EASY-HANDLER Function: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS. DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided. 4. SSL-ACCEPTOR Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 ssl-certificate-file Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format. ssl-privatekey-file Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key. ssl-privatekey-password Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password. ssl-certificate-file Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format. ssl-privatekey-file Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key. ssl-privatekey-password Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password. 5. EASY-SSL-ACCEPTOR Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. 6. REPLY Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. content-type Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*. content-length Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length. headers-out Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot. return-code Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp. external-format Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output. cookies-out Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. 7. REQUEST Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. acceptor Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object. headers-in Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers. method Initargs: :method Readers: hunchentoot:request-method The request method as a keyword. uri Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string. server-protocol Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword. local-addr Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to. local-port Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to. remote-addr Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request. remote-port Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated. content-stream Initargs: :content-stream A stream from which the request body can be read if there is one. cookies-in Readers: hunchentoot:cookies-in An alist of the cookies sent by the client. get-parameters Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client. post-parameters Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client. script-name Readers: hunchentoot:script-name The URI requested by the client without the query string. query-string Readers: hunchentoot:query-string The query string of this request. session Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request. aux-data Used to keep a user-modifiable alist with arbitrary data during the request. raw-post-data The raw string sent as the body of a POST request, populated only if not a multipart/form-data request. 8. SESSION Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started. last-click The last time this session was used. session-data Initargs: :session-data Data associated with this session - see SESSION-VALUE. max-time Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used. session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started. 9. MISCELLANEOUS FUNCTIONS aux-request-value Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced. bad-request Class client-as-string Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems. content-length* Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY. content-type* Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY. cookie-out Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive. cookie-in Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none. cookies-in* Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST. cookies-out* Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY. create-folder-dispatcher-and-handler Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder. create-prefix-dispatcher Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX. create-regex-dispatcher Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX. create-request-handler-thread Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request. create-static-file-dispatcher-and-handler Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix. decrement-taskmaster-thread-count Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests default-document-directory Function: (default-document-directory &optional sub-directory) delete-aux-request-value Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST. delete-session-value Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one. detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. dispatch-easy-handlers Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one. escape-for-html Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output. execute-acceptor Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread. get-parameter Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. get-parameters* Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST. handle-if-modified-since Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME. handle-incoming-connection Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. handle-static-file Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix. header-in Function: (header-in name request) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string. header-in* Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string. headers-in* Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST. headers-out* Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY. host Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value. http-token-p Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names). hunchentoot-error Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot. increment-taskmaster-thread-count Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. local-addr* Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to. local-port* Function: (local-port* &optional (request *request*)) Returns the port the current request connected to. log-message* Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing. maybe-invoke-debugger Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes. mime-type Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL). multi-threaded-taskmaster An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. next-session-id Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation. no-cache Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers. one-thread-per-connection-taskmaster A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. parameter Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive. parameter-error Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters. post-parameter Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. post-parameters* Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. process-request Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored. query-string* Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters). raw-post-data Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST. real-remote-addr Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value. reason-phrase Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know. recompute-request-parameters Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request. redirect Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) https http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code. referer Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header. regenerate-session-cookie-value Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value. remote-addr* Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from. remote-port* Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from. remove-session Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. request-method* Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword. request-pathname Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix. request-uri* Function: (request-uri* &optional (request *request*)) Returns the request URI. require-authorization Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. reset-session-secret Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid. reset-sessions Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR. return-code* Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp. rfc-1123-date Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE. script-name Function: (script-name object) script-name* Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters). send-headers Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing. server-protocol Function: (server-protocol object) server-protocol* Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword. session-cookie-name Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name. session-cookie-value Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects. session-created Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored. session-db Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors. session-db-lock Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise. session-gc Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P. session-start Function: (session-start object) session-too-old-p Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds. session-value Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request. session-verify Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions. set-cookie Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced. set-cookie* Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced. shutdown Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method. single-threaded-taskmaster A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. ssl-p Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P. start Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor. start-listening Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar). start-session Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser. start-thread Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers. started-p Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR. stop Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock. taskmaster-max-accept-count Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. taskmaster-max-thread-count Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. taskmaster-thread-count Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests. too-many-taskmaster-requests Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection. url-decode Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. url-encode Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. user-agent Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header. within-request-p Function: (within-request-p) True if we're in the context of a request, otherwise nil. 10. CONFIGURATION VARIABLES *catch-errors-p* Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger). *content-types-for-url-rewrite* Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS*. *default-connection-timeout* Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream. *default-content-type* Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute. *dispatch-table* Variable A global list of dispatch functions. *file-upload-hook* Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created. *handle-http-errors-p* *header-stream* Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes. *http-error-handler* *hunchentoot-default-external-format* Variable The external format used to compute the REQUEST object. *hunchentoot-version* *lisp-errors-log-level* Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO. *lisp-warnings-log-level* Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO. *log-lisp-backtraces-p* Variable Whether Lisp backtraces should be logged. Only has an effect if *LOG-LISP-ERRORS-P* is true as well. *log-lisp-errors-p* Variable Whether Lisp errors in request handlers should be logged. *log-lisp-warnings-p* Variable Whether Lisp warnings in request handlers should be logged. *methods-for-post-parameters* Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS. *rewrite-for-session-urls* Variable Whether HTML pages should possibly be rewritten for cookie-less session-management. *session-gc-frequency* Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED. *session-max-time* Variable The default time (in seconds) after which a session times out. *session-secret* Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors. *show-lisp-backtraces-p* Variable Whether Lisp errors shown in HTML output should contain backtrace information. *show-lisp-errors-p* Variable Whether Lisp errors in request handlers should be shown in HTML output. *tmp-directory* Variable Directory for temporary files created by MAKE-TMP-FILE-NAME. *use-remote-addr-for-sessions* Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers. *use-user-agent-for-sessions* Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header. 11. VARIABLES IN THE CONTEXT OF A REQUEST *acceptor* Variable The current ACCEPTOR object. *reply* Variable The current REPLY object. *request* Variable The current REQUEST object. *session* Variable The current session while in the context of a request, or NIL. 12. CONSTANTS +http-accepted+ Constant: 202 HTTP return code (202) for 'Accepted'. +http-authorization-required+ Constant: 401 HTTP return code (401) for 'Authorization Required'. +http-bad-gateway+ Constant: 502 HTTP return code (502) for 'Bad Gateway'. +http-bad-request+ Constant: 400 HTTP return code (400) for 'Bad Request'. +http-conflict+ Constant: 409 HTTP return code (409) for 'Conflict'. +http-continue+ Constant: 100 HTTP return code (100) for 'Continue'. +http-created+ Constant: 201 HTTP return code (201) for 'Created'. +http-expectation-failed+ Constant: 417 HTTP return code (417) for 'Expectation Failed'. +http-failed-dependency+ Constant: 424 HTTP return code (424) for 'Failed Dependency'. +http-forbidden+ Constant: 403 HTTP return code (403) for 'Forbidden'. +http-gateway-time-out+ Constant: 504 HTTP return code (504) for 'Gateway Time-out'. +http-gone+ Constant: 410 HTTP return code (410) for 'Gone'. +http-internal-server-error+ Constant: 500 HTTP return code (500) for 'Internal Server Error'. +http-length-required+ Constant: 411 HTTP return code (411) for 'Length Required'. +http-method-not-allowed+ Constant: 405 HTTP return code (405) for 'Method Not Allowed'. +http-moved-permanently+ Constant: 301 HTTP return code (301) for 'Moved Permanently'. +http-moved-temporarily+ Constant: 302 HTTP return code (302) for 'Moved Temporarily'. +http-multi-status+ Constant: 207 HTTP return code (207) for 'Multi-Status'. +http-multiple-choices+ Constant: 300 HTTP return code (300) for 'Multiple Choices'. +http-network-authentication-required+ Constant: 511 HTTP return code (511) for 'Network Authentication Required'. +http-no-content+ Constant: 204 HTTP return code (204) for 'No Content'. +http-non-authoritative-information+ Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'. +http-not-acceptable+ Constant: 406 HTTP return code (406) for 'Not Acceptable'. +http-not-found+ Constant: 404 HTTP return code (404) for 'Not Found'. +http-not-implemented+ Constant: 501 HTTP return code (501) for 'Not Implemented'. +http-not-modified+ Constant: 304 HTTP return code (304) for 'Not Modified'. +http-ok+ Constant: 200 HTTP return code (200) for 'OK'. +http-partial-content+ Constant: 206 HTTP return code (206) for 'Partial Content'. +http-payment-required+ Constant: 402 HTTP return code (402) for 'Payment Required'. +http-precondition-failed+ Constant: 412 HTTP return code (412) for 'Precondition Failed'. +http-precondition-required+ Constant: 428 HTTP return code (428) for 'Precondition Required'. +http-proxy-authentication-required+ Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'. +http-request-entity-too-large+ Constant: 413 HTTP return code (413) for 'Request Entity Too Large'. +http-request-header-fields-too-large+ Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'. +http-request-time-out+ Constant: 408 HTTP return code (408) for 'Request Time-out'. +http-request-uri-too-large+ Constant: 414 HTTP return code (414) for 'Request-URI Too Large'. +http-requested-range-not-satisfiable+ Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'. +http-reset-content+ Constant: 205 HTTP return code (205) for 'Reset Content'. +http-see-other+ Constant: 303 HTTP return code (303) for 'See Other'. +http-service-unavailable+ Constant: 503 HTTP return code (503) for 'Service Unavailable'. +http-switching-protocols+ Constant: 101 HTTP return code (101) for 'Switching Protocols'. +http-temporary-redirect+ Constant: 307 HTTP return code (307) for 'Temporary Redirect'. +http-too-many-requests+ Constant: 429 HTTP return code (429) for 'Too Many Requests'. +http-unsupported-media-type+ Constant: 415 HTTP return code (415) for 'Unsupported Media Type'. +http-use-proxy+ Constant: 305 HTTP return code (305) for 'Use Proxy'. +http-version-not-supported+ Constant: 505 HTTP return code (505) for 'Version not supported'. 13. HUNCHENTOOT-CONDITION Class Superclass for all conditions related to Hunchentoot. 14. HUNCHENTOOT-WARNING Class Superclass for all warnings related to Hunchentoot. 15. TASKMASTER Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. acceptor Readers: hunchentoot:taskmaster-acceptor Writers: (setf hunchentoot:taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for. Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"hunchentoot - The Common Lisp web server (formerly TBNL)"},{"location":"hunchentoot.bak/#hunchentoot-the-common-lisp-web-server-formerly-tbnl","text":"Version: 1.2.38","title":"hunchentoot - The Common Lisp web server (formerly TBNL)"},{"location":"hunchentoot.bak/#introduction","text":"Hunchentoot is a web server written in Common Lisp and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . It currently works with LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Complete documentation for Hunchentoot including details about how to install it can be found in the docs directory or at the project website .","title":"INTRODUCTION"},{"location":"hunchentoot.bak/#download-and-installation","text":"(ql:quickload :hunchentoot) Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests.","title":"Download and Installation"},{"location":"hunchentoot.bak/#without-clssl","text":"You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it.","title":"Without cl+ssl"},{"location":"hunchentoot.bak/#clbuild","text":"Hunchentoot and its dependencies can also be installed with clbuild .","title":"clbuild"},{"location":"hunchentoot.bak/#gentoo-linux","text":"There's also a port for Gentoo Linux thanks to Matthew Kennedy.","title":"Gentoo Linux"},{"location":"hunchentoot.bak/#running-hunchentoot-on-port-80","text":"Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic.","title":"Running Hunchentoot on port 80"},{"location":"hunchentoot.bak/#hunchentoot-behind-a-proxy","text":"If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache.","title":"Hunchentoot behind a proxy"},{"location":"hunchentoot.bak/#support","text":"The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"Support"},{"location":"hunchentoot.bak/#more-documentation-tutorials-and-add-ons","text":"Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it.","title":"MORE DOCUMENTATION, TUTORIALS AND ADD-ONS"},{"location":"hunchentoot.bak/#api-reference","text":"","title":"API REFERENCE"},{"location":"hunchentoot.bak/#1-acceptor","text":"Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time.","title":"1. ACCEPTOR"},{"location":"hunchentoot.bak/#port","text":"Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started.","title":"port"},{"location":"hunchentoot.bak/#address","text":"Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default.","title":"address"},{"location":"hunchentoot.bak/#name","text":"Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM.","title":"name"},{"location":"hunchentoot.bak/#request-class","text":"Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST.","title":"request-class"},{"location":"hunchentoot.bak/#reply-class","text":"Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY. HUNCHENTOOT:TASKMASTER Initargs: :taskmasterdocumentation: The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp.","title":"reply-class"},{"location":"hunchentoot.bak/#output-chunking-p","text":"Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL.","title":"output-chunking-p"},{"location":"hunchentoot.bak/#input-chunking-p","text":"Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL.","title":"input-chunking-p"},{"location":"hunchentoot.bak/#persistent-connections-p","text":"Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors.","title":"persistent-connections-p"},{"location":"hunchentoot.bak/#read-timeout","text":"Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"read-timeout"},{"location":"hunchentoot.bak/#write-timeout","text":"Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"write-timeout"},{"location":"hunchentoot.bak/#listen-socket","text":"The socket listening for incoming connections.","title":"listen-socket"},{"location":"hunchentoot.bak/#listen-backlog","text":"Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections.","title":"listen-backlog"},{"location":"hunchentoot.bak/#acceptor-shutdown-p","text":"Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL.","title":"acceptor-shutdown-p"},{"location":"hunchentoot.bak/#requests-in-progress","text":"Initform: 0 The number of requests currently in progress.","title":"requests-in-progress"},{"location":"hunchentoot.bak/#shutdown-queue","text":"A condition variable used with soft shutdown, signaled when all requests have been processed.","title":"shutdown-queue"},{"location":"hunchentoot.bak/#shutdown-lock","text":"The lock protecting the shutdown-queue condition variable and the requests-in-progress counter.","title":"shutdown-lock"},{"location":"hunchentoot.bak/#access-log-destination","text":"Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"access-log-destination"},{"location":"hunchentoot.bak/#message-log-destination","text":"Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"message-log-destination"},{"location":"hunchentoot.bak/#error-template-directory","text":"Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response.","title":"error-template-directory"},{"location":"hunchentoot.bak/#document-root","text":"Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request.#### acceptor-access-log-destination","title":"document-root"},{"location":"hunchentoot.bak/#2-easy-acceptor","text":"Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: HUNCHENTOOT:ACCEPTOR Direct subclasses: HUNCHENTOOT:EASY-SSL-ACCEPTOR","title":"2. EASY-ACCEPTOR"},{"location":"hunchentoot.bak/#3-define-easy-handler","text":"Function: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS. DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided.","title":"3. DEFINE-EASY-HANDLER"},{"location":"hunchentoot.bak/#4-ssl-acceptor","text":"Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80","title":"4. SSL-ACCEPTOR"},{"location":"hunchentoot.bak/#ssl-certificate-file","text":"Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format.","title":"ssl-certificate-file"},{"location":"hunchentoot.bak/#ssl-privatekey-file","text":"Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key.","title":"ssl-privatekey-file"},{"location":"hunchentoot.bak/#ssl-privatekey-password","text":"Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password.","title":"ssl-privatekey-password"},{"location":"hunchentoot.bak/#ssl-certificate-file_1","text":"Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format.","title":"ssl-certificate-file"},{"location":"hunchentoot.bak/#ssl-privatekey-file_1","text":"Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key.","title":"ssl-privatekey-file"},{"location":"hunchentoot.bak/#ssl-privatekey-password_1","text":"Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password.","title":"ssl-privatekey-password"},{"location":"hunchentoot.bak/#5-easy-ssl-acceptor","text":"Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections.","title":"5. EASY-SSL-ACCEPTOR"},{"location":"hunchentoot.bak/#6-reply","text":"Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class.","title":"6. REPLY"},{"location":"hunchentoot.bak/#content-type","text":"Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*.","title":"content-type"},{"location":"hunchentoot.bak/#content-length","text":"Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length.","title":"content-length"},{"location":"hunchentoot.bak/#headers-out","text":"Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.","title":"headers-out"},{"location":"hunchentoot.bak/#return-code","text":"Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code"},{"location":"hunchentoot.bak/#external-format","text":"Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output.","title":"external-format"},{"location":"hunchentoot.bak/#cookies-out","text":"Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp.","title":"cookies-out"},{"location":"hunchentoot.bak/#reply-external-format","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot.bak/#7-request","text":"Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class.","title":"7. REQUEST"},{"location":"hunchentoot.bak/#acceptor","text":"Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object.","title":"acceptor"},{"location":"hunchentoot.bak/#headers-in","text":"Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers.","title":"headers-in"},{"location":"hunchentoot.bak/#method","text":"Initargs: :method Readers: hunchentoot:request-method The request method as a keyword.","title":"method"},{"location":"hunchentoot.bak/#uri","text":"Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string.","title":"uri"},{"location":"hunchentoot.bak/#server-protocol","text":"Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword.","title":"server-protocol"},{"location":"hunchentoot.bak/#local-addr","text":"Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to.","title":"local-addr"},{"location":"hunchentoot.bak/#local-port","text":"Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to.","title":"local-port"},{"location":"hunchentoot.bak/#remote-addr","text":"Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request.","title":"remote-addr"},{"location":"hunchentoot.bak/#remote-port","text":"Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated.","title":"remote-port"},{"location":"hunchentoot.bak/#content-stream","text":"Initargs: :content-stream A stream from which the request body can be read if there is one.","title":"content-stream"},{"location":"hunchentoot.bak/#cookies-in","text":"Readers: hunchentoot:cookies-in An alist of the cookies sent by the client.","title":"cookies-in"},{"location":"hunchentoot.bak/#get-parameters","text":"Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client.","title":"get-parameters"},{"location":"hunchentoot.bak/#post-parameters","text":"Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client.","title":"post-parameters"},{"location":"hunchentoot.bak/#script-name","text":"Readers: hunchentoot:script-name The URI requested by the client without the query string.","title":"script-name"},{"location":"hunchentoot.bak/#query-string","text":"Readers: hunchentoot:query-string The query string of this request.","title":"query-string"},{"location":"hunchentoot.bak/#session","text":"Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request.","title":"session"},{"location":"hunchentoot.bak/#aux-data","text":"Used to keep a user-modifiable alist with arbitrary data during the request.","title":"aux-data"},{"location":"hunchentoot.bak/#raw-post-data","text":"The raw string sent as the body of a POST request, populated only if not a multipart/form-data request.","title":"raw-post-data"},{"location":"hunchentoot.bak/#8-session","text":"Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY.","title":"8. SESSION"},{"location":"hunchentoot.bak/#session-id","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot.bak/#session-string","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot.bak/#user-agent","text":"Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot.bak/#remote-addr_1","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot.bak/#session-start","text":"Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot.bak/#last-click","text":"The last time this session was used.","title":"last-click"},{"location":"hunchentoot.bak/#session-data","text":"Initargs: :session-data Data associated with this session - see SESSION-VALUE.","title":"session-data"},{"location":"hunchentoot.bak/#max-time","text":"Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used.","title":"max-time"},{"location":"hunchentoot.bak/#session-id_1","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot.bak/#session-string_1","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot.bak/#user-agent_1","text":"Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot.bak/#remote-addr_2","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot.bak/#session-start_1","text":"Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot.bak/#9-miscellaneous-functions","text":"","title":"9. MISCELLANEOUS FUNCTIONS"},{"location":"hunchentoot.bak/#aux-request-value","text":"Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced.","title":"aux-request-value"},{"location":"hunchentoot.bak/#bad-request","text":"Class","title":"bad-request"},{"location":"hunchentoot.bak/#client-as-string","text":"Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems.","title":"client-as-string"},{"location":"hunchentoot.bak/#content-length_1","text":"Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY.","title":"content-length*"},{"location":"hunchentoot.bak/#content-type_1","text":"Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY.","title":"content-type*"},{"location":"hunchentoot.bak/#cookie-out","text":"Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive.","title":"cookie-out"},{"location":"hunchentoot.bak/#cookie-in","text":"Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none.","title":"cookie-in"},{"location":"hunchentoot.bak/#cookies-in_1","text":"Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST.","title":"cookies-in*"},{"location":"hunchentoot.bak/#cookies-out_1","text":"Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY.","title":"cookies-out*"},{"location":"hunchentoot.bak/#create-folder-dispatcher-and-handler","text":"Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder.","title":"create-folder-dispatcher-and-handler"},{"location":"hunchentoot.bak/#create-prefix-dispatcher","text":"Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX.","title":"create-prefix-dispatcher"},{"location":"hunchentoot.bak/#create-regex-dispatcher","text":"Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX.","title":"create-regex-dispatcher"},{"location":"hunchentoot.bak/#create-request-handler-thread","text":"Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request.","title":"create-request-handler-thread"},{"location":"hunchentoot.bak/#create-static-file-dispatcher-and-handler","text":"Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix.","title":"create-static-file-dispatcher-and-handler"},{"location":"hunchentoot.bak/#decrement-taskmaster-thread-count","text":"Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests","title":"decrement-taskmaster-thread-count"},{"location":"hunchentoot.bak/#default-document-directory","text":"Function: (default-document-directory &optional sub-directory)","title":"default-document-directory"},{"location":"hunchentoot.bak/#delete-aux-request-value","text":"Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST.","title":"delete-aux-request-value"},{"location":"hunchentoot.bak/#delete-session-value","text":"Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one.","title":"delete-session-value"},{"location":"hunchentoot.bak/#detach-socket","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot.bak/#dispatch-easy-handlers","text":"Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one.","title":"dispatch-easy-handlers"},{"location":"hunchentoot.bak/#escape-for-html","text":"Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output.","title":"escape-for-html"},{"location":"hunchentoot.bak/#execute-acceptor","text":"Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread.","title":"execute-acceptor"},{"location":"hunchentoot.bak/#get-parameter","text":"Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"get-parameter"},{"location":"hunchentoot.bak/#get-parameters_1","text":"Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST.","title":"get-parameters*"},{"location":"hunchentoot.bak/#handle-if-modified-since","text":"Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME.","title":"handle-if-modified-since"},{"location":"hunchentoot.bak/#handle-incoming-connection","text":"Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument.","title":"handle-incoming-connection"},{"location":"hunchentoot.bak/#handle-request","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot.bak/#handle-static-file","text":"Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix.","title":"handle-static-file"},{"location":"hunchentoot.bak/#header-in","text":"Function: (header-in name request) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.","title":"header-in"},{"location":"hunchentoot.bak/#header-in_1","text":"Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.","title":"header-in*"},{"location":"hunchentoot.bak/#headers-in_1","text":"Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST.","title":"headers-in*"},{"location":"hunchentoot.bak/#headers-out_1","text":"Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY.","title":"headers-out*"},{"location":"hunchentoot.bak/#host","text":"Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value.","title":"host"},{"location":"hunchentoot.bak/#http-token-p","text":"Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names).","title":"http-token-p"},{"location":"hunchentoot.bak/#hunchentoot-error","text":"Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot.","title":"hunchentoot-error"},{"location":"hunchentoot.bak/#increment-taskmaster-thread-count","text":"Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests.","title":"increment-taskmaster-thread-count"},{"location":"hunchentoot.bak/#initialize-connection-stream","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot.bak/#local-addr_1","text":"Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to.","title":"local-addr*"},{"location":"hunchentoot.bak/#local-port_1","text":"Function: (local-port* &optional (request *request*)) Returns the port the current request connected to.","title":"local-port*"},{"location":"hunchentoot.bak/#log-message","text":"Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing.","title":"log-message*"},{"location":"hunchentoot.bak/#maybe-invoke-debugger","text":"Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes.","title":"maybe-invoke-debugger"},{"location":"hunchentoot.bak/#mime-type","text":"Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL).","title":"mime-type"},{"location":"hunchentoot.bak/#multi-threaded-taskmaster","text":"An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster.","title":"multi-threaded-taskmaster"},{"location":"hunchentoot.bak/#next-session-id","text":"Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation.","title":"next-session-id"},{"location":"hunchentoot.bak/#no-cache","text":"Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers.","title":"no-cache"},{"location":"hunchentoot.bak/#one-thread-per-connection-taskmaster","text":"A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations.","title":"one-thread-per-connection-taskmaster"},{"location":"hunchentoot.bak/#parameter","text":"Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive.","title":"parameter"},{"location":"hunchentoot.bak/#parameter-error","text":"Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters.","title":"parameter-error"},{"location":"hunchentoot.bak/#post-parameter","text":"Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"post-parameter"},{"location":"hunchentoot.bak/#post-parameters_1","text":"Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST.","title":"post-parameters*"},{"location":"hunchentoot.bak/#process-connection","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing.","title":"process-connection"},{"location":"hunchentoot.bak/#process-request","text":"Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored.","title":"process-request"},{"location":"hunchentoot.bak/#query-string_1","text":"Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters).","title":"query-string*"},{"location":"hunchentoot.bak/#raw-post-data_1","text":"Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST.","title":"raw-post-data"},{"location":"hunchentoot.bak/#real-remote-addr","text":"Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value.","title":"real-remote-addr"},{"location":"hunchentoot.bak/#reason-phrase","text":"Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know.","title":"reason-phrase"},{"location":"hunchentoot.bak/#recompute-request-parameters","text":"Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request.","title":"recompute-request-parameters"},{"location":"hunchentoot.bak/#redirect","text":"Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) https http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code.","title":"redirect"},{"location":"hunchentoot.bak/#referer","text":"Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header.","title":"referer"},{"location":"hunchentoot.bak/#regenerate-session-cookie-value","text":"Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value.","title":"regenerate-session-cookie-value"},{"location":"hunchentoot.bak/#remote-addr_3","text":"Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from.","title":"remote-addr*"},{"location":"hunchentoot.bak/#remote-port_1","text":"Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from.","title":"remote-port*"},{"location":"hunchentoot.bak/#remove-session","text":"Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database.","title":"remove-session"},{"location":"hunchentoot.bak/#reply-external-format_1","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot.bak/#request-method","text":"Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword.","title":"request-method*"},{"location":"hunchentoot.bak/#request-pathname","text":"Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix.","title":"request-pathname"},{"location":"hunchentoot.bak/#request-uri","text":"Function: (request-uri* &optional (request *request*)) Returns the request URI.","title":"request-uri*"},{"location":"hunchentoot.bak/#require-authorization","text":"Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM.","title":"require-authorization"},{"location":"hunchentoot.bak/#reset-connection-stream","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot.bak/#reset-session-secret","text":"Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid.","title":"reset-session-secret"},{"location":"hunchentoot.bak/#reset-sessions","text":"Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR.","title":"reset-sessions"},{"location":"hunchentoot.bak/#return-code_1","text":"Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code*"},{"location":"hunchentoot.bak/#rfc-1123-date","text":"Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE.","title":"rfc-1123-date"},{"location":"hunchentoot.bak/#script-name_1","text":"Function: (script-name object)","title":"script-name"},{"location":"hunchentoot.bak/#script-name_2","text":"Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters).","title":"script-name*"},{"location":"hunchentoot.bak/#send-headers","text":"Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing.","title":"send-headers"},{"location":"hunchentoot.bak/#server-protocol_1","text":"Function: (server-protocol object)","title":"server-protocol"},{"location":"hunchentoot.bak/#server-protocol_2","text":"Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword.","title":"server-protocol*"},{"location":"hunchentoot.bak/#session-cookie-name","text":"Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name.","title":"session-cookie-name"},{"location":"hunchentoot.bak/#session-cookie-value","text":"Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects.","title":"session-cookie-value"},{"location":"hunchentoot.bak/#session-created","text":"Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored.","title":"session-created"},{"location":"hunchentoot.bak/#session-db","text":"Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors.","title":"session-db"},{"location":"hunchentoot.bak/#session-db-lock","text":"Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise.","title":"session-db-lock"},{"location":"hunchentoot.bak/#session-gc","text":"Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P.","title":"session-gc"},{"location":"hunchentoot.bak/#session-start_2","text":"Function: (session-start object)","title":"session-start"},{"location":"hunchentoot.bak/#session-too-old-p","text":"Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds.","title":"session-too-old-p"},{"location":"hunchentoot.bak/#session-value","text":"Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request.","title":"session-value"},{"location":"hunchentoot.bak/#session-verify","text":"Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions.","title":"session-verify"},{"location":"hunchentoot.bak/#set-cookie","text":"Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced.","title":"set-cookie"},{"location":"hunchentoot.bak/#set-cookie_1","text":"Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced.","title":"set-cookie*"},{"location":"hunchentoot.bak/#shutdown","text":"Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method.","title":"shutdown"},{"location":"hunchentoot.bak/#single-threaded-taskmaster","text":"A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION.","title":"single-threaded-taskmaster"},{"location":"hunchentoot.bak/#ssl-p","text":"Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P.","title":"ssl-p"},{"location":"hunchentoot.bak/#start","text":"Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor.","title":"start"},{"location":"hunchentoot.bak/#start-listening","text":"Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar).","title":"start-listening"},{"location":"hunchentoot.bak/#start-session","text":"Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser.","title":"start-session"},{"location":"hunchentoot.bak/#start-thread","text":"Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers.","title":"start-thread"},{"location":"hunchentoot.bak/#started-p","text":"Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR.","title":"started-p"},{"location":"hunchentoot.bak/#stop","text":"Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock.","title":"stop"},{"location":"hunchentoot.bak/#taskmaster-max-accept-count","text":"Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"taskmaster-max-accept-count"},{"location":"hunchentoot.bak/#taskmaster-max-thread-count","text":"Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"taskmaster-max-thread-count"},{"location":"hunchentoot.bak/#taskmaster-thread-count","text":"Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests.","title":"taskmaster-thread-count"},{"location":"hunchentoot.bak/#too-many-taskmaster-requests","text":"Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection.","title":"too-many-taskmaster-requests"},{"location":"hunchentoot.bak/#url-decode","text":"Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-decode"},{"location":"hunchentoot.bak/#url-encode","text":"Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-encode"},{"location":"hunchentoot.bak/#user-agent_2","text":"Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header.","title":"user-agent"},{"location":"hunchentoot.bak/#within-request-p","text":"Function: (within-request-p) True if we're in the context of a request, otherwise nil.","title":"within-request-p"},{"location":"hunchentoot.bak/#10-configuration-variables","text":"","title":"10. CONFIGURATION VARIABLES"},{"location":"hunchentoot.bak/#catch-errors-p","text":"Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger).","title":"*catch-errors-p*"},{"location":"hunchentoot.bak/#content-types-for-url-rewrite","text":"Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS*.","title":"*content-types-for-url-rewrite*"},{"location":"hunchentoot.bak/#default-connection-timeout","text":"Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream.","title":"*default-connection-timeout*"},{"location":"hunchentoot.bak/#default-content-type","text":"Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute.","title":"*default-content-type*"},{"location":"hunchentoot.bak/#dispatch-table","text":"Variable A global list of dispatch functions.","title":"*dispatch-table*"},{"location":"hunchentoot.bak/#file-upload-hook","text":"Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created.","title":"*file-upload-hook*"},{"location":"hunchentoot.bak/#handle-http-errors-p","text":"","title":"*handle-http-errors-p*"},{"location":"hunchentoot.bak/#header-stream","text":"Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes.","title":"*header-stream*"},{"location":"hunchentoot.bak/#http-error-handler","text":"","title":"*http-error-handler*"},{"location":"hunchentoot.bak/#hunchentoot-default-external-format","text":"Variable The external format used to compute the REQUEST object.","title":"*hunchentoot-default-external-format*"},{"location":"hunchentoot.bak/#hunchentoot-version","text":"","title":"*hunchentoot-version*"},{"location":"hunchentoot.bak/#lisp-errors-log-level","text":"Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO.","title":"*lisp-errors-log-level*"},{"location":"hunchentoot.bak/#lisp-warnings-log-level","text":"Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO.","title":"*lisp-warnings-log-level*"},{"location":"hunchentoot.bak/#log-lisp-backtraces-p","text":"Variable Whether Lisp backtraces should be logged. Only has an effect if *LOG-LISP-ERRORS-P* is true as well.","title":"*log-lisp-backtraces-p*"},{"location":"hunchentoot.bak/#log-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be logged.","title":"*log-lisp-errors-p*"},{"location":"hunchentoot.bak/#log-lisp-warnings-p","text":"Variable Whether Lisp warnings in request handlers should be logged.","title":"*log-lisp-warnings-p*"},{"location":"hunchentoot.bak/#methods-for-post-parameters","text":"Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS.","title":"*methods-for-post-parameters*"},{"location":"hunchentoot.bak/#rewrite-for-session-urls","text":"Variable Whether HTML pages should possibly be rewritten for cookie-less session-management.","title":"*rewrite-for-session-urls*"},{"location":"hunchentoot.bak/#session-gc-frequency","text":"Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED.","title":"*session-gc-frequency*"},{"location":"hunchentoot.bak/#session-max-time","text":"Variable The default time (in seconds) after which a session times out.","title":"*session-max-time*"},{"location":"hunchentoot.bak/#session-secret","text":"Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors.","title":"*session-secret*"},{"location":"hunchentoot.bak/#show-lisp-backtraces-p","text":"Variable Whether Lisp errors shown in HTML output should contain backtrace information.","title":"*show-lisp-backtraces-p*"},{"location":"hunchentoot.bak/#show-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be shown in HTML output.","title":"*show-lisp-errors-p*"},{"location":"hunchentoot.bak/#tmp-directory","text":"Variable Directory for temporary files created by MAKE-TMP-FILE-NAME.","title":"*tmp-directory*"},{"location":"hunchentoot.bak/#use-remote-addr-for-sessions","text":"Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers.","title":"*use-remote-addr-for-sessions*"},{"location":"hunchentoot.bak/#use-user-agent-for-sessions","text":"Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header.","title":"*use-user-agent-for-sessions*"},{"location":"hunchentoot.bak/#11-variables-in-the-context-of-a-request","text":"","title":"11. VARIABLES IN THE CONTEXT OF A REQUEST"},{"location":"hunchentoot.bak/#acceptor_1","text":"Variable The current ACCEPTOR object.","title":"*acceptor*"},{"location":"hunchentoot.bak/#reply","text":"Variable The current REPLY object.","title":"*reply*"},{"location":"hunchentoot.bak/#request","text":"Variable The current REQUEST object.","title":"*request*"},{"location":"hunchentoot.bak/#session_1","text":"Variable The current session while in the context of a request, or NIL.","title":"*session*"},{"location":"hunchentoot.bak/#12-constants","text":"","title":"12. CONSTANTS"},{"location":"hunchentoot.bak/#http-accepted","text":"Constant: 202 HTTP return code (202) for 'Accepted'.","title":"+http-accepted+"},{"location":"hunchentoot.bak/#http-authorization-required","text":"Constant: 401 HTTP return code (401) for 'Authorization Required'.","title":"+http-authorization-required+"},{"location":"hunchentoot.bak/#http-bad-gateway","text":"Constant: 502 HTTP return code (502) for 'Bad Gateway'.","title":"+http-bad-gateway+"},{"location":"hunchentoot.bak/#http-bad-request","text":"Constant: 400 HTTP return code (400) for 'Bad Request'.","title":"+http-bad-request+"},{"location":"hunchentoot.bak/#http-conflict","text":"Constant: 409 HTTP return code (409) for 'Conflict'.","title":"+http-conflict+"},{"location":"hunchentoot.bak/#http-continue","text":"Constant: 100 HTTP return code (100) for 'Continue'.","title":"+http-continue+"},{"location":"hunchentoot.bak/#http-created","text":"Constant: 201 HTTP return code (201) for 'Created'.","title":"+http-created+"},{"location":"hunchentoot.bak/#http-expectation-failed","text":"Constant: 417 HTTP return code (417) for 'Expectation Failed'.","title":"+http-expectation-failed+"},{"location":"hunchentoot.bak/#http-failed-dependency","text":"Constant: 424 HTTP return code (424) for 'Failed Dependency'.","title":"+http-failed-dependency+"},{"location":"hunchentoot.bak/#http-forbidden","text":"Constant: 403 HTTP return code (403) for 'Forbidden'.","title":"+http-forbidden+"},{"location":"hunchentoot.bak/#http-gateway-time-out","text":"Constant: 504 HTTP return code (504) for 'Gateway Time-out'.","title":"+http-gateway-time-out+"},{"location":"hunchentoot.bak/#http-gone","text":"Constant: 410 HTTP return code (410) for 'Gone'.","title":"+http-gone+"},{"location":"hunchentoot.bak/#http-internal-server-error","text":"Constant: 500 HTTP return code (500) for 'Internal Server Error'.","title":"+http-internal-server-error+"},{"location":"hunchentoot.bak/#http-length-required","text":"Constant: 411 HTTP return code (411) for 'Length Required'.","title":"+http-length-required+"},{"location":"hunchentoot.bak/#http-method-not-allowed","text":"Constant: 405 HTTP return code (405) for 'Method Not Allowed'.","title":"+http-method-not-allowed+"},{"location":"hunchentoot.bak/#http-moved-permanently","text":"Constant: 301 HTTP return code (301) for 'Moved Permanently'.","title":"+http-moved-permanently+"},{"location":"hunchentoot.bak/#http-moved-temporarily","text":"Constant: 302 HTTP return code (302) for 'Moved Temporarily'.","title":"+http-moved-temporarily+"},{"location":"hunchentoot.bak/#http-multi-status","text":"Constant: 207 HTTP return code (207) for 'Multi-Status'.","title":"+http-multi-status+"},{"location":"hunchentoot.bak/#http-multiple-choices","text":"Constant: 300 HTTP return code (300) for 'Multiple Choices'.","title":"+http-multiple-choices+"},{"location":"hunchentoot.bak/#http-network-authentication-required","text":"Constant: 511 HTTP return code (511) for 'Network Authentication Required'.","title":"+http-network-authentication-required+"},{"location":"hunchentoot.bak/#http-no-content","text":"Constant: 204 HTTP return code (204) for 'No Content'.","title":"+http-no-content+"},{"location":"hunchentoot.bak/#http-non-authoritative-information","text":"Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'.","title":"+http-non-authoritative-information+"},{"location":"hunchentoot.bak/#http-not-acceptable","text":"Constant: 406 HTTP return code (406) for 'Not Acceptable'.","title":"+http-not-acceptable+"},{"location":"hunchentoot.bak/#http-not-found","text":"Constant: 404 HTTP return code (404) for 'Not Found'.","title":"+http-not-found+"},{"location":"hunchentoot.bak/#http-not-implemented","text":"Constant: 501 HTTP return code (501) for 'Not Implemented'.","title":"+http-not-implemented+"},{"location":"hunchentoot.bak/#http-not-modified","text":"Constant: 304 HTTP return code (304) for 'Not Modified'.","title":"+http-not-modified+"},{"location":"hunchentoot.bak/#http-ok","text":"Constant: 200 HTTP return code (200) for 'OK'.","title":"+http-ok+"},{"location":"hunchentoot.bak/#http-partial-content","text":"Constant: 206 HTTP return code (206) for 'Partial Content'.","title":"+http-partial-content+"},{"location":"hunchentoot.bak/#http-payment-required","text":"Constant: 402 HTTP return code (402) for 'Payment Required'.","title":"+http-payment-required+"},{"location":"hunchentoot.bak/#http-precondition-failed","text":"Constant: 412 HTTP return code (412) for 'Precondition Failed'.","title":"+http-precondition-failed+"},{"location":"hunchentoot.bak/#http-precondition-required","text":"Constant: 428 HTTP return code (428) for 'Precondition Required'.","title":"+http-precondition-required+"},{"location":"hunchentoot.bak/#http-proxy-authentication-required","text":"Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'.","title":"+http-proxy-authentication-required+"},{"location":"hunchentoot.bak/#http-request-entity-too-large","text":"Constant: 413 HTTP return code (413) for 'Request Entity Too Large'.","title":"+http-request-entity-too-large+"},{"location":"hunchentoot.bak/#http-request-header-fields-too-large","text":"Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'.","title":"+http-request-header-fields-too-large+"},{"location":"hunchentoot.bak/#http-request-time-out","text":"Constant: 408 HTTP return code (408) for 'Request Time-out'.","title":"+http-request-time-out+"},{"location":"hunchentoot.bak/#http-request-uri-too-large","text":"Constant: 414 HTTP return code (414) for 'Request-URI Too Large'.","title":"+http-request-uri-too-large+"},{"location":"hunchentoot.bak/#http-requested-range-not-satisfiable","text":"Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'.","title":"+http-requested-range-not-satisfiable+"},{"location":"hunchentoot.bak/#http-reset-content","text":"Constant: 205 HTTP return code (205) for 'Reset Content'.","title":"+http-reset-content+"},{"location":"hunchentoot.bak/#http-see-other","text":"Constant: 303 HTTP return code (303) for 'See Other'.","title":"+http-see-other+"},{"location":"hunchentoot.bak/#http-service-unavailable","text":"Constant: 503 HTTP return code (503) for 'Service Unavailable'.","title":"+http-service-unavailable+"},{"location":"hunchentoot.bak/#http-switching-protocols","text":"Constant: 101 HTTP return code (101) for 'Switching Protocols'.","title":"+http-switching-protocols+"},{"location":"hunchentoot.bak/#http-temporary-redirect","text":"Constant: 307 HTTP return code (307) for 'Temporary Redirect'.","title":"+http-temporary-redirect+"},{"location":"hunchentoot.bak/#http-too-many-requests","text":"Constant: 429 HTTP return code (429) for 'Too Many Requests'.","title":"+http-too-many-requests+"},{"location":"hunchentoot.bak/#http-unsupported-media-type","text":"Constant: 415 HTTP return code (415) for 'Unsupported Media Type'.","title":"+http-unsupported-media-type+"},{"location":"hunchentoot.bak/#http-use-proxy","text":"Constant: 305 HTTP return code (305) for 'Use Proxy'.","title":"+http-use-proxy+"},{"location":"hunchentoot.bak/#http-version-not-supported","text":"Constant: 505 HTTP return code (505) for 'Version not supported'.","title":"+http-version-not-supported+"},{"location":"hunchentoot.bak/#13-hunchentoot-condition","text":"Class Superclass for all conditions related to Hunchentoot.","title":"13. HUNCHENTOOT-CONDITION"},{"location":"hunchentoot.bak/#14-hunchentoot-warning","text":"Class Superclass for all warnings related to Hunchentoot.","title":"14. HUNCHENTOOT-WARNING"},{"location":"hunchentoot.bak/#15-taskmaster","text":"Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used.","title":"15. TASKMASTER"},{"location":"hunchentoot.bak/#acceptor_2","text":"Readers: hunchentoot:taskmaster-acceptor Writers: (setf hunchentoot:taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for. Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"acceptor"},{"location":"hunchentoot/","text":"hunchentoot - The Common Lisp web server (formerly TBNL) Version: 1.2.38 INTRODUCTION Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website . GETTING STARTED Installation using quicklisp See the section on Installation under Defacto Libraries on Home Page . Serving local files To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor Going dynamic create-X-dispatcher To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler define-easy-handler define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for. Accessing GET and POST parameters Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request . More documentation, tutorials and add-ons Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it. API REFERENCE 1. ACCEPTOR Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR RELEVANT METHODS accept-connections Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped. acceptor-log-access Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request. acceptor-log-message Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments. acceptor-status-message Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available. detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. start Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor. start-listening Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar). stop Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock. started-p Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR. SLOTS acceptor-shutdown-p Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL. access-log-destination Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. address Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default. document-root Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request. error-template-directory Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response. listen-backlog Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections. listen-socket The socket listening for incoming connections. message-log-destination Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging. input-chunking-p Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL. name Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM. output-chunking-p Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL. persistent-connections-p Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors. port Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started. read-timeout Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. reply-class Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY. request-class Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST. requests-in-progress Initform: 0 The number of requests currently in progress. shutdown-lock The lock protecting the shutdown-queue condition variable and the requests-in-progress counter. shutdown-queue A condition variable used with soft shutdown, signaled when all requests have been processed. taskmaster Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp. write-timeout Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout. 2. EASY-ACCEPTOR Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR 3. DEFINE-EASY-HANDLER Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided. 4. SSL-ACCEPTOR Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR DIRECT SLOTS Also see slots for the superclass. ssl-certificate-file Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format. ssl-privatekey-file Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key. ssl-privatekey-password Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password. 5. EASY-SSL-ACCEPTOR Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses. 6. REPLY Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS headers-out* Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY. content-length* Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY. content-type* Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY. cookie-out Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive. cookies-out* Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY. return-code* Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp. send-headers Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. SLOTS content-type Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*. content-length Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length. headers-out Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot. return-code Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp. external-format Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output. cookies-out Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp. 7. REQUEST Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses. RELEVANT METHODS real-remote-addr Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value. parameter Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive. get-parameter Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. get-parameters* Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST. post-parameter Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive. post-parameters* Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST. cookie-in Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none. cookies-in* Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST. host Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value. query-string* Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters). referer Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header. request-method* Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword. request-uri* Function: (request-uri* &optional (request *request*)) Returns the request URI. server-protocol* Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword. user-agent Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header. header-in* Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string. headers-in* Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST. remote-addr* Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from. remote-port* Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from. local-addr* Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to. local-port* Function: (local-port* &optional (request *request*)) Returns the port the current request connected to. script-name* Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters). aux-request-value Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced. delete-aux-request-value Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST. authorization Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header. raw-post-data Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST. recompute-request-parameters Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request. process-request Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. handle-request Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers. acceptor-dispatch-request Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request. SLOTS acceptor Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object. headers-in Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers. method Initargs: :method Readers: hunchentoot:request-method The request method as a keyword. uri Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string. server-protocol Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword. local-addr Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to. local-port Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to. remote-addr Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request. remote-port Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated. content-stream Initargs: :content-stream A stream from which the request body can be read if there is one. cookies-in Readers: hunchentoot:cookies-in An alist of the cookies sent by the client. get-parameters Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client. post-parameters Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client. script-name Readers: hunchentoot:script-name The URI requested by the client without the query string. query-string Readers: hunchentoot:query-string The query string of this request. session Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request. aux-data Used to keep a user-modifiable alist with arbitrary data during the request. raw-post-data The raw string sent as the body of a POST request, populated only if not a multipart/form-data request. 8. SESSION Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application. RELEVANT METHODS start-session Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser. session-value Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request. delete-session-value Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one. remove-session Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database. SLOTS session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started. last-click The last time this session was used. session-data Initargs: :session-data Data associated with this session - see SESSION-VALUE. max-time Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used. session-id Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session. session-string The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter. user-agent Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created. remote-addr Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR. session-start Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started. 9. MISCELLANEOUS FUNCTIONS bad-request Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses. client-as-string Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems. create-folder-dispatcher-and-handler Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder. create-prefix-dispatcher Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX. create-regex-dispatcher Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX. create-request-handler-thread Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request. create-static-file-dispatcher-and-handler Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix. decrement-taskmaster-thread-count Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests default-document-directory Function: (default-document-directory &optional sub-directory) detach-socket Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. dispatch-easy-handlers Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one. escape-for-html Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output. handle-if-modified-since Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME. handle-static-file Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix. http-token-p Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names). hunchentoot-error Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot. increment-taskmaster-thread-count Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests. initialize-connection-stream Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. log-message* Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing. maybe-invoke-debugger Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes. mime-type Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL). next-session-id Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation. no-cache Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers. parameter-error Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters. process-connection Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. reason-phrase Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know. redirect Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code. regenerate-session-cookie-value Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value. reply-external-format* Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output. request-pathname Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix. require-authorization Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM. reset-connection-stream Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. reset-session-secret Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid. reset-sessions Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR. rfc-1123-date Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE. script-name Function: (script-name object) server-protocol Function: (server-protocol object) session-cookie-name Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name. session-cookie-value Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects. session-created Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored. session-db Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors. session-db-lock Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise. session-gc Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P. session-too-old-p Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds. session-verify Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions. set-cookie Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced. set-cookie* Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced. ssl-p Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P. taskmaster-max-accept-count Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. taskmaster-max-thread-count Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. taskmaster-thread-count Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests. too-many-taskmaster-requests Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection. url-decode Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. url-encode Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. within-request-p Function: (within-request-p) True if we're in the context of a request, otherwise nil. 10. CONFIGURATION VARIABLES *catch-errors-p* Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger). *content-types-for-url-rewrite* Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* . *default-connection-timeout* Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream. *default-content-type* Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute. *dispatch-table* Variable A global list of dispatch functions. *file-upload-hook* Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created. *handle-http-errors-p* *header-stream* Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes. *http-error-handler* *hunchentoot-default-external-format* Variable The external format used to compute the REQUEST object. *hunchentoot-version* *lisp-errors-log-level* Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO. *lisp-warnings-log-level* Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO. *log-lisp-backtraces-p* Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well. *log-lisp-errors-p* Variable Whether Lisp errors in request handlers should be logged. *log-lisp-warnings-p* Variable Whether Lisp warnings in request handlers should be logged. *methods-for-post-parameters* Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS . *rewrite-for-session-urls* Variable Whether HTML pages should possibly be rewritten for cookie-less session-management. *session-gc-frequency* Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED . *session-max-time* Variable The default time (in seconds) after which a session times out. *session-secret* Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors. *show-lisp-backtraces-p* Variable Whether Lisp errors shown in HTML output should contain backtrace information. *show-lisp-errors-p* Variable Whether Lisp errors in request handlers should be shown in HTML output. *tmp-directory* Variable Directory for temporary files created by MAKE-TMP-FILE-NAME. *use-remote-addr-for-sessions* Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers. *use-user-agent-for-sessions* Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header. 11. VARIABLES IN THE CONTEXT OF A REQUEST *acceptor* Variable The current ACCEPTOR object. *reply* Variable The current REPLY object. *request* Variable The current REQUEST object. *session* Variable The current SESSION (can be NIL). 12. CONSTANTS +http-accepted+ Constant: 202 HTTP return code (202) for 'Accepted'. +http-authorization-required+ Constant: 401 HTTP return code (401) for 'Authorization Required'. +http-bad-gateway+ Constant: 502 HTTP return code (502) for 'Bad Gateway'. +http-bad-request+ Constant: 400 HTTP return code (400) for 'Bad Request'. +http-conflict+ Constant: 409 HTTP return code (409) for 'Conflict'. +http-continue+ Constant: 100 HTTP return code (100) for 'Continue'. +http-created+ Constant: 201 HTTP return code (201) for 'Created'. +http-expectation-failed+ Constant: 417 HTTP return code (417) for 'Expectation Failed'. +http-failed-dependency+ Constant: 424 HTTP return code (424) for 'Failed Dependency'. +http-forbidden+ Constant: 403 HTTP return code (403) for 'Forbidden'. +http-gateway-time-out+ Constant: 504 HTTP return code (504) for 'Gateway Time-out'. +http-gone+ Constant: 410 HTTP return code (410) for 'Gone'. +http-internal-server-error+ Constant: 500 HTTP return code (500) for 'Internal Server Error'. +http-length-required+ Constant: 411 HTTP return code (411) for 'Length Required'. +http-method-not-allowed+ Constant: 405 HTTP return code (405) for 'Method Not Allowed'. +http-moved-permanently+ Constant: 301 HTTP return code (301) for 'Moved Permanently'. +http-moved-temporarily+ Constant: 302 HTTP return code (302) for 'Moved Temporarily'. +http-multi-status+ Constant: 207 HTTP return code (207) for 'Multi-Status'. +http-multiple-choices+ Constant: 300 HTTP return code (300) for 'Multiple Choices'. +http-network-authentication-required+ Constant: 511 HTTP return code (511) for 'Network Authentication Required'. +http-no-content+ Constant: 204 HTTP return code (204) for 'No Content'. +http-non-authoritative-information+ Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'. +http-not-acceptable+ Constant: 406 HTTP return code (406) for 'Not Acceptable'. +http-not-found+ Constant: 404 HTTP return code (404) for 'Not Found'. +http-not-implemented+ Constant: 501 HTTP return code (501) for 'Not Implemented'. +http-not-modified+ Constant: 304 HTTP return code (304) for 'Not Modified'. +http-ok+ Constant: 200 HTTP return code (200) for 'OK'. +http-partial-content+ Constant: 206 HTTP return code (206) for 'Partial Content'. +http-payment-required+ Constant: 402 HTTP return code (402) for 'Payment Required'. +http-precondition-failed+ Constant: 412 HTTP return code (412) for 'Precondition Failed'. +http-precondition-required+ Constant: 428 HTTP return code (428) for 'Precondition Required'. +http-proxy-authentication-required+ Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'. +http-request-entity-too-large+ Constant: 413 HTTP return code (413) for 'Request Entity Too Large'. +http-request-header-fields-too-large+ Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'. +http-request-time-out+ Constant: 408 HTTP return code (408) for 'Request Time-out'. +http-request-uri-too-large+ Constant: 414 HTTP return code (414) for 'Request-URI Too Large'. +http-requested-range-not-satisfiable+ Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'. +http-reset-content+ Constant: 205 HTTP return code (205) for 'Reset Content'. +http-see-other+ Constant: 303 HTTP return code (303) for 'See Other'. +http-service-unavailable+ Constant: 503 HTTP return code (503) for 'Service Unavailable'. +http-switching-protocols+ Constant: 101 HTTP return code (101) for 'Switching Protocols'. +http-temporary-redirect+ Constant: 307 HTTP return code (307) for 'Temporary Redirect'. +http-too-many-requests+ Constant: 429 HTTP return code (429) for 'Too Many Requests'. +http-unsupported-media-type+ Constant: 415 HTTP return code (415) for 'Unsupported Media Type'. +http-use-proxy+ Constant: 305 HTTP return code (305) for 'Use Proxy'. +http-version-not-supported+ Constant: 505 HTTP return code (505) for 'Version not supported'. 13. HUNCHENTOOT-CONDITION Class Superclass for all conditions related to Hunchentoot. 14. HUNCHENTOOT-WARNING Class Superclass for all warnings related to Hunchentoot. 15. TASKMASTER taskmaster Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER RELEVANT METHODS shutdown Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method. execute-acceptor Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread. handle-incoming-connection Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument. start-thread Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers. DIRECT SLOTS acceptor Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for. multi-threaded-taskmaster Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER DIRECT SLOTS acceptor-process A process that accepts incoming connections and hands them off to new processes for request handling. one-thread-per-connection-taskmaster Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses. DIRECT SLOTS max-thread-count Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit. thread-count Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running. thread-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count. max-accept-count Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT. accept-count Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy. accept-count-lock In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count. wait-queue A queue that we use to wait for a free connection. wait-lock The lock for the connection wait queue. worker-thread-name-format Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\" single-threaded-taskmaster Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER ADVANCED TOPICS CUSTOMIZING SESSION BEHAVIOUR For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify CUSTOMIZING ACCEPTOR BEHAVIOUR If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream An example of how to subclass ACCEPTOR This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader. TASKMASTERS As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. SOME MORE TECHNICAL DETAILS Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests. Without cl+ssl You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it. clbuild Hunchentoot and its dependencies can also be installed with clbuild . Gentoo Linux There's also a port for Gentoo Linux thanks to Matthew Kennedy. Running Hunchentoot on port 80 Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic. Hunchentoot behind a proxy If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache. SUPPORT The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"hunchentoot - The Common Lisp web server (formerly TBNL)"},{"location":"hunchentoot/#hunchentoot-the-common-lisp-web-server-formerly-tbnl","text":"Version: 1.2.38","title":"hunchentoot - The Common Lisp web server (formerly TBNL)"},{"location":"hunchentoot/#introduction","text":"Hunchentoot is a web server written in Common Lisp and a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. CL-WHO or HTML-TEMPLATE . Hunchentoot should work with most popular lisp implementations including SBCL, CCL, LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads . Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp . Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Official documentation for Hunchentoot can be found in the docs directory or at the project website .","title":"INTRODUCTION"},{"location":"hunchentoot/#getting-started","text":"","title":"GETTING STARTED"},{"location":"hunchentoot/#installation-using-quicklisp","text":"See the section on Installation under Defacto Libraries on Home Page .","title":"Installation using quicklisp"},{"location":"hunchentoot/#serving-local-files","text":"To start the server, simply (defvar *acceptor*) (setq *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) You should see something - but not very interesting - at \" http://127.0.0.1:4242/ \" in your browser. By default, Hunchentoot serves files from the www/ directory from its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. If installed via quicklisp, see (ql:where-is-system \"hunchentoot\") . See acceptor slots for a list of various slots (with or without initargs ). And configuration variables for a list of various configuration options for hunchentoot, such as whether to *catch-errors-p or *log-lisp-errors-p* and more. Acceptors provided with hunchentoot: acceptor easy-acceptor ssl-acceptor easy-ssl-acceptor","title":"Serving local files"},{"location":"hunchentoot/#going-dynamic","text":"","title":"Going dynamic"},{"location":"hunchentoot/#create-x-dispatcher","text":"To bind an existing function to a route, we create-prefix-dispatcher that we push onto the *dispatch-table* (just a global list of dispatch functions): (defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello.html\" 'hello) hunchentoot:*dispatch-table*) To create a route with a regexp, we use create-regex-dispatcher , where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner. In all, there exist create-folder-dispatcher-and-handler create-prefix-dispatcher create-regex-dispatcher create-static-file-dispatcher-and-handler","title":"create-X-dispatcher"},{"location":"hunchentoot/#define-easy-handler","text":"define-easy-handler allows to create a function and to bind it to an uri at once. For instance: (hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit http://localhost:4242/yo or add parameters to the url: http://localhost:4242/yo?name=Alice . Note that we didn't explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. This handler also works for another acceptor, say another one opened at port 4444: http://localhost:4444/yo?name=Bob In fact, define-easy-handler accepts an acceptor-names parameter that defines which acceptors it works for.","title":"define-easy-handler"},{"location":"hunchentoot/#accessing-get-and-post-parameters","text":"Query parameters are accessible with (hunchentoot:parameter \"my-param\") while in the context of a request . It acts on the default *request* object which is passed to all handlers. There also are get-paramater and post-parameter . See also the Variables in the context of a request .","title":"Accessing GET and POST parameters"},{"location":"hunchentoot/#more-documentation-tutorials-and-add-ons","text":"Adam Petersen has written a book called \"Lisp for the Web\" which explains how Hunchentoot and some other libraries can be used to build web sites. See also the Web Development - Cookbook . Implementing a blog in Common Lisp - Vetle Roeim Extensions and related softwares: Clack is a web server abstraction layer, defaulting to Hunchentoot. hunchentoot-cgi (by Cyrus Harmo) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Caveman , Radiance , Snooze or again Weblocks are frameworks compatible with it.","title":"More documentation, tutorials and add-ons"},{"location":"hunchentoot/#api-reference","text":"","title":"API REFERENCE"},{"location":"hunchentoot/#1-acceptor","text":"Class To create a Hunchentoot webserver, you make an instance of this class and use the generic function START to start it (and STOP to stop it). Use the :PORT initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. Direct superclasses: STANDARD-OBJECT Direct subclasses: EASY-ACCEPTOR , SSL-ACCEPTOR","title":"1. ACCEPTOR"},{"location":"hunchentoot/#relevant-methods","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#accept-connections","text":"Function: (accept-connections acceptor) In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it retusn only once the acceptor has been stopped.","title":"accept-connections"},{"location":"hunchentoot/#acceptor-log-access","text":"Function: (acceptor-log-access acceptor &key return-code) Function to call to log access to the acceptor. The RETURN-CODE, CONTENT and CONTENT-LENGTH keyword arguments contain additional information about the request to log. In addition, it can use the standard request accessor functions that are available to handler functions to find out more information about the request.","title":"acceptor-log-access"},{"location":"hunchentoot/#acceptor-log-message","text":"Function: (acceptor-log-message acceptor log-level format-string &rest format-arguments) Function to call to log messages by the ACCEPTOR. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments.","title":"acceptor-log-message"},{"location":"hunchentoot/#acceptor-status-message","text":"Function: (acceptor-status-message acceptor http-status-code &key &allow-other-keys) This function is called after the request's handler has been invoked to convert the HTTP-STATUS-CODE to a HTML message to be displayed to the user. If this function returns a string, that string is sent to the client instead of the content produced by the handler, if any. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named \\<code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${ }. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available.","title":"acceptor-status-message"},{"location":"hunchentoot/#detach-socket","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#initialize-connection-stream","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#process-connection","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required.","title":"process-connection"},{"location":"hunchentoot/#reset-connection-stream","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#start","text":"Function: (start acceptor) Starts the ACCEPTOR so that it begins accepting connections. Returns the acceptor.","title":"start"},{"location":"hunchentoot/#start-listening","text":"Function: (start-listening acceptor) Sets up a listen socket for the given ACCEPTOR and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar).","title":"start-listening"},{"location":"hunchentoot/#stop","text":"Function: (stop acceptor &key soft) Stops the ACCEPTOR so that it no longer accepts requests. If SOFT is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that SOFT must not be set when calling STOP from within a request handler, as that will deadlock.","title":"stop"},{"location":"hunchentoot/#started-p","text":"Function: (started-p acceptor) Tells if ACCEPTOR has been started. The default implementation simply queries ACCEPTOR for its listening status, so if T is returned to the calling thread, then some thread has called START or some thread's call to STOP hasn't finished. If NIL is returned either some thread has called STOP, or some thread's call to START hasn't finished or START was never called at all for ACCEPTOR.","title":"started-p"},{"location":"hunchentoot/#slots","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor-shutdown-p","text":"Initform: T A flag that makes the acceptor shutdown itself when set to something other than NIL.","title":"acceptor-shutdown-p"},{"location":"hunchentoot/#access-log-destination","text":"Initargs: :access-log-destination Readers: hunchentoot:acceptor-access-log-destination Writers: (setf hunchentoot:acceptor-access-log-destination) Destination of the access log which contains one log entry per request handled in a format similar to Apache's access.log. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"access-log-destination"},{"location":"hunchentoot/#address","text":"Initargs: :address Readers: hunchentoot:acceptor-address The address the acceptor is listening on. If address is a string denoting an IP address, then the server only receives connections for that address. This must be one of the addresses associated with the machine and allowed values are host names such as \"www.zappa.com\" and address strings such as \"72.3.247.29\". If address is NIL, then the server will receive connections to all IP addresses on the machine. This is the default.","title":"address"},{"location":"hunchentoot/#document-root","text":"Initargs: :document-root Readers: hunchentoot:acceptor-document-root Writers: (setf hunchentoot:acceptor-document-root) Directory pathname that points to files that are served by the acceptor if no more specific acceptor-dispatch-request method handles the request.","title":"document-root"},{"location":"hunchentoot/#error-template-directory","text":"Initargs: :error-template-directory Readers: hunchentoot:acceptor-error-template-directory Writers: (setf hunchentoot:acceptor-error-template-directory) Directory pathname that contains error message template files for server-generated error messages. Files must be named .html with representing the HTTP return code that the file applies to, i.e. 404.html would be used as the content for a HTTP 404 Not found response.","title":"error-template-directory"},{"location":"hunchentoot/#listen-backlog","text":"Initargs: :listen-backlog Readers: hunchentoot:acceptor-listen-backlog Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections.","title":"listen-backlog"},{"location":"hunchentoot/#listen-socket","text":"The socket listening for incoming connections.","title":"listen-socket"},{"location":"hunchentoot/#message-log-destination","text":"Initargs: :message-log-destination Readers: hunchentoot:acceptor-message-log-destination Writers: (setf hunchentoot:acceptor-message-log-destination) Destination of the server error log which is used to log informational, warning and error messages in a free-text format intended for human inspection. Can be set to a pathname or string designating the log file, to a open output stream or to NIL to suppress logging.","title":"message-log-destination"},{"location":"hunchentoot/#input-chunking-p","text":"Initargs: :input-chunking-p Readers: hunchentoot:acceptor-input-chunking-p Writers: (setf hunchentoot:acceptor-input-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for input, i.e. when accepting request bodies from the client. The default is T and there's usually no reason to change this to NIL.","title":"input-chunking-p"},{"location":"hunchentoot/#name","text":"Initargs: :name Readers: hunchentoot:acceptor-name Writers: (setf hunchentoot:acceptor-name) The optional name of the acceptor, a symbol. This name can be utilized when defining \"easy handlers\" - see DEFINE-EASY-HANDLER. The default name is an uninterned symbol as returned by GENSYM.","title":"name"},{"location":"hunchentoot/#output-chunking-p","text":"Initargs: :output-chunking-p Readers: hunchentoot:acceptor-output-chunking-p Writers: (setf hunchentoot:acceptor-output-chunking-p) A generalized boolean denoting whether the acceptor may use chunked encoding for output, i.e. when sending data to the client. The default is T and there's usually no reason to change this to NIL.","title":"output-chunking-p"},{"location":"hunchentoot/#persistent-connections-p","text":"Initargs: :persistent-connections-p Readers: hunchentoot:acceptor-persistent-connections-p Writers: (setf hunchentoot:acceptor-persistent-connections-p) A generalized boolean denoting whether the acceptor supports persistent connections, which is the default for threaded acceptors. If this property is NIL, Hunchentoot closes each incoming connection after having processed one request. This is the default for non-threaded acceptors.","title":"persistent-connections-p"},{"location":"hunchentoot/#port","text":"Initargs: :port Readers: hunchentoot:acceptor-port The port the acceptor is listening on. The default is 80. Note that depending on your operating system you might need special privileges to listen on port 80. When 0, the port will be chosen by the system the first time the acceptor is started.","title":"port"},{"location":"hunchentoot/#read-timeout","text":"Initargs: :read-timeout Readers: hunchentoot:acceptor-read-timeout The read timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"read-timeout"},{"location":"hunchentoot/#reply-class","text":"Initargs: :reply-class Readers: hunchentoot:acceptor-reply-class Writers: (setf hunchentoot:acceptor-reply-class) Determines which class of reply objects is created when a request is served in and should be (a symbol naming) a class which inherits from REPLY. The default is the symbol REPLY.","title":"reply-class"},{"location":"hunchentoot/#request-class","text":"Initargs: :request-class Readers: hunchentoot:acceptor-request-class Writers: (setf hunchentoot:acceptor-request-class) Determines which class of request objects is created when a request comes in and should be (a symbol naming) a class which inherits from REQUEST. The default is the symbol REQUEST.","title":"request-class"},{"location":"hunchentoot/#requests-in-progress","text":"Initform: 0 The number of requests currently in progress.","title":"requests-in-progress"},{"location":"hunchentoot/#shutdown-lock","text":"The lock protecting the shutdown-queue condition variable and the requests-in-progress counter.","title":"shutdown-lock"},{"location":"hunchentoot/#shutdown-queue","text":"A condition variable used with soft shutdown, signaled when all requests have been processed.","title":"shutdown-queue"},{"location":"hunchentoot/#taskmaster","text":"Initargs: :taskmaster The taskmaster (i.e. an instance of a subclass of TASKMASTER) that is responsible for scheduling the work for this acceptor. The default depends on the MP capabilities of the underlying Lisp.","title":"taskmaster"},{"location":"hunchentoot/#write-timeout","text":"Initargs: :write-timeout Readers: hunchentoot:acceptor-write-timeout The write timeout of the acceptor, specified in (fractional) seconds. The precise semantics of this parameter is determined by the underlying Lisp's implementation of socket timeouts. NIL means no timeout.","title":"write-timeout"},{"location":"hunchentoot/#2-easy-acceptor","text":"Class This is the acceptor of the \"easy\" Hunchentoot framework. Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"2. EASY-ACCEPTOR"},{"location":"hunchentoot/#3-define-easy-handler","text":"Macro: (define-easy-handler description lambda-list &body body) Defines a handler with the body BODY and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS . DESCRIPTION is either a symbol NAME or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type) LAMBDA-LIST is a list the elements of which are either a symbol VAR or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type) The resulting handler will be a Lisp function with the name NAME and keyword parameters named by the VAR symbols. Each VAR will be bound to the value of the GET or POST parameter called REAL-NAME (a string) before BODY is executed. If REAL-NAME is not provided, it will be computed by downcasing the symbol name of VAR. If URI (which is evaluated) is provided, then it must be a string or a function designator for a function of one argument. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a string and the script name of a request is URI, or if URI designates a function and applying this function to the current request object returns a true value. ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which means that the handler will be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). ACCEPTOR-NAMES can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on REQUEST-TYPE which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be used. The value of VAR will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if PARAMETER-TYPE (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, VAR's value will be NIL. If PARAMETER-TYPE is 'STRING, VAR's value remains as is. If PARAMETER-TYPE is 'INTEGER and the parameter string consists solely of decimal digits, VAR's value will be the corresponding integer, otherwise NIL. If PARAMETER-TYPE is 'KEYWORD, VAR's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If PARAMETER-TYPE is 'CHARACTER and the parameter string is of length one, VAR's value will be the single character of this string, otherwise NIL. If PARAMETER-TYPE is 'BOOLEAN, VAR's value will always be T (unless it is NIL by the first rule above, of course). If PARAMETER-TYPE is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple' types, but PARAMETER-TYPE can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type' below. In the case of 'LIST, all GET/POST parameters called REAL-NAME will be collected, converted to the inner type, and assembled into a list which will be the value of VAR. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil \"~A[~A]\" real-name n) where N is a non-negative integer, will be assembled into an array where the Nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of VAR, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function), but KEY-TYPE and TEST-FUNCTION can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil \"~A{~A}\" real-name key) (where KEY is a string that doesn't contain curly brackets) will become the values (after conversion to INNER-TYPE) of a hash table with test function TEST-FUNCTION where KEY (after conversion to KEY-TYPE) will be the corresponding key. Note that VAR will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE (the default of which is 'STRING) will be used instead. If the result of the computations above would be that VAR would be bound to NIL, then INIT-FORM (if provided) will be evaluated instead, and VAR will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, VAR will always be bound to the result of evaluating INIT-FORM unless a corresponding keyword argument is provided.","title":"3. DEFINE-EASY-HANDLER"},{"location":"hunchentoot/#4-ssl-acceptor","text":"Class Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 Direct superclasses: ACCEPTOR Direct subclasses: EASY-SSL-ACCEPTOR","title":"4. SSL-ACCEPTOR"},{"location":"hunchentoot/#direct-slots","text":"Also see slots for the superclass.","title":"DIRECT SLOTS"},{"location":"hunchentoot/#ssl-certificate-file","text":"Initargs: :ssl-certificate-file Readers: hunchentoot:acceptor-ssl-certificate-file A pathname designator for a certificate file in PEM format.","title":"ssl-certificate-file"},{"location":"hunchentoot/#ssl-privatekey-file","text":"Initargs: :ssl-privatekey-file Readers: hunchentoot:acceptor-ssl-privatekey-file A pathname designator for a private key file in PEM format, or (only on LispWorks) NIL if the certificate file contains the private key.","title":"ssl-privatekey-file"},{"location":"hunchentoot/#ssl-privatekey-password","text":"Initargs: :ssl-privatekey-password Readers: hunchentoot:acceptor-ssl-privatekey-password The password for the private key file or NIL for no password.","title":"ssl-privatekey-password"},{"location":"hunchentoot/#5-easy-ssl-acceptor","text":"Class This is an acceptor that mixes the \"easy\" Hunchentoot with SSL connections. Direct superclasses: EASY-ACCEPTOR , SSL-ACCEPTOR No subclasses.","title":"5. EASY-SSL-ACCEPTOR"},{"location":"hunchentoot/#6-reply","text":"Class Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the REPLY-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"6. REPLY"},{"location":"hunchentoot/#relevant-methods_1","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#headers-out","text":"Function: (headers-out* &optional (reply *reply*)) Returns an alist of the outgoing headers associated with the REPLY object REPLY.","title":"headers-out*"},{"location":"hunchentoot/#content-length","text":"Function: (content-length* &optional (reply *reply*)) The outgoing 'Content-Length' http header of REPLY.","title":"content-length*"},{"location":"hunchentoot/#content-type","text":"Function: (content-type* &optional (reply *reply*)) The outgoing 'Content-Type' http header of REPLY.","title":"content-type*"},{"location":"hunchentoot/#cookie-out","text":"Function: (cookie-out name &optional (reply *reply*)) Returns the current value of the outgoing cookie named NAME. Search is case-sensitive.","title":"cookie-out"},{"location":"hunchentoot/#cookies-out","text":"Function: (cookies-out* &optional (reply *reply*)) Returns an alist of the outgoing cookies associated with the REPLY object REPLY.","title":"cookies-out*"},{"location":"hunchentoot/#return-code","text":"Function: (return-code* &optional (reply *reply*)) The http return code of REPLY. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code*"},{"location":"hunchentoot/#send-headers","text":"Function: (send-headers) Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request. If your handlers return the full body as a string or as an array of octets you should NOT call this function. This function does not return control to the caller during HEAD request processing.","title":"send-headers"},{"location":"hunchentoot/#reply-external-format","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#slots_1","text":"","title":"SLOTS"},{"location":"hunchentoot/#content-type_1","text":"Readers: hunchentoot:content-type The outgoing 'Content-Type' http header which defaults to the value of *DEFAULT-CONTENT-TYPE*.","title":"content-type"},{"location":"hunchentoot/#content-length_1","text":"Readers: hunchentoot:content-length The outgoing 'Content-Length' http header which defaults NIL. If this is NIL, Hunchentoot will compute the content length.","title":"content-length"},{"location":"hunchentoot/#headers-out_1","text":"Readers: hunchentoot:headers-out An alist of the outgoing http headers not including the 'Set-Cookie', 'Content-Length', and 'Content-Type' headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.","title":"headers-out"},{"location":"hunchentoot/#return-code_1","text":"Initform: hunchentoot:+http-ok+ Readers: hunchentoot:return-code Writers: (setf hunchentoot:return-code) The http return code of this reply. The return codes Hunchentoot can handle are defined in specials.lisp.","title":"return-code"},{"location":"hunchentoot/#external-format","text":"Initform: hunchentoot:*hunchentoot-default-external-format* Readers: hunchentoot:reply-external-format Writers: (setf hunchentoot:reply-external-format) The external format of the reply - used for character output.","title":"external-format"},{"location":"hunchentoot/#cookies-out_1","text":"Readers: hunchentoot:cookies-out Writers: (setf hunchentoot:cookies-out) The outgoing cookies. This slot's value should only be modified by the functions defined in cookies.lisp.","title":"cookies-out"},{"location":"hunchentoot/#7-request","text":"Class Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. Direct superclasses: STANDARD-OBJECT No subclasses.","title":"7. REQUEST"},{"location":"hunchentoot/#relevant-methods_2","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#real-remote-addr","text":"Function: (real-remote-addr &optional (request *request*)) Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value.","title":"real-remote-addr"},{"location":"hunchentoot/#parameter","text":"Function: (parameter name &optional (request *request*)) Returns the GET or the POST parameter with name NAME (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive.","title":"parameter"},{"location":"hunchentoot/#get-parameter","text":"Function: (get-parameter name &optional (request *request*)) Returns the GET parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"get-parameter"},{"location":"hunchentoot/#get-parameters","text":"Function: (get-parameters* &optional (request *request*)) Returns an alist of the GET parameters associated with the REQUEST object REQUEST.","title":"get-parameters*"},{"location":"hunchentoot/#post-parameter","text":"Function: (post-parameter name &optional (request *request*)) Returns the POST parameter with name NAME (a string) - or NIL if there is none. Search is case-sensitive.","title":"post-parameter"},{"location":"hunchentoot/#post-parameters","text":"Function: (post-parameters* &optional (request *request*)) Returns an alist of the POST parameters associated with the REQUEST object REQUEST.","title":"post-parameters*"},{"location":"hunchentoot/#cookie-in","text":"Function: (cookie-in name &optional (request *request*)) Returns the cookie with the name NAME (a string) as sent by the browser - or NIL if there is none.","title":"cookie-in"},{"location":"hunchentoot/#cookies-in","text":"Function: (cookies-in* &optional (request *request*)) Returns an alist of all cookies associated with the REQUEST object REQUEST.","title":"cookies-in*"},{"location":"hunchentoot/#host","text":"Function: (host &optional (request *request*)) Returns the 'Host' incoming http header value.","title":"host"},{"location":"hunchentoot/#query-string","text":"Function: (query-string* &optional (request *request*)) Returns the query string of the REQUEST object REQUEST. That's the part behind the question mark (i.e. the GET parameters).","title":"query-string*"},{"location":"hunchentoot/#referer","text":"Function: (referer &optional (request *request*)) Returns the 'Referer' (sic!) http header.","title":"referer"},{"location":"hunchentoot/#request-method","text":"Function: (request-method* &optional (request *request*)) Returns the request method as a Lisp keyword.","title":"request-method*"},{"location":"hunchentoot/#request-uri","text":"Function: (request-uri* &optional (request *request*)) Returns the request URI.","title":"request-uri*"},{"location":"hunchentoot/#server-protocol","text":"Function: (server-protocol* &optional (request *request*)) Returns the request protocol as a Lisp keyword.","title":"server-protocol*"},{"location":"hunchentoot/#user-agent","text":"Function: (user-agent &optional (request *request*)) Returns the 'User-Agent' http header.","title":"user-agent"},{"location":"hunchentoot/#header-in","text":"Function: (header-in* name &optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.","title":"header-in*"},{"location":"hunchentoot/#headers-in","text":"Function: (headers-in* &optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST.","title":"headers-in*"},{"location":"hunchentoot/#remote-addr","text":"Function: (remote-addr* &optional (request *request*)) Returns the address the current request originated from.","title":"remote-addr*"},{"location":"hunchentoot/#remote-port","text":"Function: (remote-port* &optional (request *request*)) Returns the port the current request originated from.","title":"remote-port*"},{"location":"hunchentoot/#local-addr","text":"Function: (local-addr* &optional (request *request*)) Returns the address the current request connected to.","title":"local-addr*"},{"location":"hunchentoot/#local-port","text":"Function: (local-port* &optional (request *request*)) Returns the port the current request connected to.","title":"local-port*"},{"location":"hunchentoot/#script-name","text":"Function: (script-name* &optional (request *request*)) Returns the file name of the REQUEST object REQUEST. That's the requested URI without the query string (i.e the GET parameters).","title":"script-name*"},{"location":"hunchentoot/#aux-request-value","text":"Function: (aux-request-value symbol &optional (request *request*)) Returns the value associated with SYMBOL from the request object REQUEST (the default is the current request) if it exists. The second return value is true if such a value was found. Sets the value associated with SYMBOL from the request object REQUEST (default is *REQUEST*). If there is already a value associated with SYMBOL it will be replaced.","title":"aux-request-value"},{"location":"hunchentoot/#delete-aux-request-value","text":"Function: (delete-aux-request-value symbol &optional (request *request*)) Removes the value associated with SYMBOL from the request object REQUEST.","title":"delete-aux-request-value"},{"location":"hunchentoot/#authorization","text":"Function: (authorization &optional (request *request*)) Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header.","title":"authorization"},{"location":"hunchentoot/#raw-post-data","text":"Function: (raw-post-data &key (request *request*) external-format force-text force-binary want-stream) Returns the content sent by the client if there was any (unless the content type was \"multipart/form-data\"). By default, the result is a string if the type of the Content-Type' media type is \"text\", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset' parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through EXTERNAL-FORMAT) in which case the result will unconditionally be a string. Likewise, you can provide a true value for FORCE-TEXT which will force Hunchentoot to act as if the type of the media type had been \"text\". Or you can provide a true value for FORCE-BINARY which means that you want a vector of octets at any rate. If, however, you provide a true value for WANT-STREAM, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. If the content type of the request was multipart/form-data' or application/x-www-form-urlencoded', the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for WANT-STREAM. Note that this function is slightly misnamed because a client can send content even if the request method is not POST.","title":"raw-post-data"},{"location":"hunchentoot/#recompute-request-parameters","text":"Function: (recompute-request-parameters &key (request *request*) (external-format *hunchentoot-default-external-format*)) Recomputes the GET and POST parameters for the REQUEST object REQUEST. This only makes sense if you're switching external formats during the request.","title":"recompute-request-parameters"},{"location":"hunchentoot/#process-request","text":"Function: (process-request request) This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST to select and call a handler and sends the output of this handler to the client using START-OUTPUT. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. Essentially, you can view process-request as a thin wrapper around HANDLE-REQUEST. The return value of this function is ignored.","title":"process-request"},{"location":"hunchentoot/#handle-request","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#handle-request_1","text":"Function: (handle-request acceptor request) This function is called once the request has been read and a REQUEST object has been created. Its job is to set up standard error handling and request logging. Might be a good place for around methods specialized for your subclass of ACCEPTOR which bind or rebind special variables which can then be accessed by your handlers.","title":"handle-request"},{"location":"hunchentoot/#acceptor-dispatch-request","text":"Function: (acceptor-dispatch-request acceptor request) This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request.","title":"acceptor-dispatch-request"},{"location":"hunchentoot/#slots_2","text":"","title":"SLOTS"},{"location":"hunchentoot/#acceptor","text":"Initargs: :acceptor Readers: hunchentoot:request-acceptor The acceptor which created this request object.","title":"acceptor"},{"location":"hunchentoot/#headers-in_1","text":"Initargs: :headers-in Readers: hunchentoot:headers-in An alist of the incoming headers.","title":"headers-in"},{"location":"hunchentoot/#method","text":"Initargs: :method Readers: hunchentoot:request-method The request method as a keyword.","title":"method"},{"location":"hunchentoot/#uri","text":"Initargs: :uri Readers: hunchentoot:request-uri The request URI as a string.","title":"uri"},{"location":"hunchentoot/#server-protocol_1","text":"Initargs: :server-protocol Readers: hunchentoot:server-protocol The HTTP protocol as a keyword.","title":"server-protocol"},{"location":"hunchentoot/#local-addr_1","text":"Initargs: :local-addr Readers: hunchentoot:local-addr The IP address of the local system that the client connected to.","title":"local-addr"},{"location":"hunchentoot/#local-port_1","text":"Initargs: :local-port Readers: hunchentoot:local-port The TCP port number of the local system that the client connected to.","title":"local-port"},{"location":"hunchentoot/#remote-addr_1","text":"Initargs: :remote-addr Readers: hunchentoot:remote-addr The IP address of the client that initiated this request.","title":"remote-addr"},{"location":"hunchentoot/#remote-port_1","text":"Initargs: :remote-port Readers: hunchentoot:remote-port The TCP port number of the client socket from which this request originated.","title":"remote-port"},{"location":"hunchentoot/#content-stream","text":"Initargs: :content-stream A stream from which the request body can be read if there is one.","title":"content-stream"},{"location":"hunchentoot/#cookies-in_1","text":"Readers: hunchentoot:cookies-in An alist of the cookies sent by the client.","title":"cookies-in"},{"location":"hunchentoot/#get-parameters_1","text":"Readers: hunchentoot:get-parameters An alist of the GET parameters sent by the client.","title":"get-parameters"},{"location":"hunchentoot/#post-parameters_1","text":"Readers: hunchentoot:post-parameters An alist of the POST parameters sent by the client.","title":"post-parameters"},{"location":"hunchentoot/#script-name_1","text":"Readers: hunchentoot:script-name The URI requested by the client without the query string.","title":"script-name"},{"location":"hunchentoot/#query-string_1","text":"Readers: hunchentoot:query-string The query string of this request.","title":"query-string"},{"location":"hunchentoot/#session","text":"Readers: hunchentoot:session Writers: (setf hunchentoot:session) The session object associated with this request.","title":"session"},{"location":"hunchentoot/#aux-data","text":"Used to keep a user-modifiable alist with arbitrary data during the request.","title":"aux-data"},{"location":"hunchentoot/#raw-post-data_1","text":"The raw string sent as the body of a POST request, populated only if not a multipart/form-data request.","title":"raw-post-data"},{"location":"hunchentoot/#8-session","text":"Class SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects altogether and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. Direct superclasses: STANDARD-OBJECT No subclasses. Hunchentoot supports sessions : Once a request handler has called START-SESSION , Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION* . This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old . Old sessions are automatically removed . Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks , and should be used when a user logs in according to the application.","title":"8. SESSION"},{"location":"hunchentoot/#relevant-methods_3","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#start-session","text":"Function: (start-session) Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser.","title":"start-session"},{"location":"hunchentoot/#session-value","text":"Function: (session-value symbol &optional (session *session*)) Returns the value associated with SYMBOL from the session object SESSION (the default is the current session) if it exists. Sets the value associated with SYMBOL from the session object SESSION. If there is already a value associated with SYMBOL it will be replaced. Will automatically start a session if none was supplied and there's no session for the current request.","title":"session-value"},{"location":"hunchentoot/#delete-session-value","text":"Function: (delete-session-value symbol &optional (session *session*)) Removes the value associated with SYMBOL from SESSION if there is one.","title":"delete-session-value"},{"location":"hunchentoot/#remove-session","text":"Function: (remove-session session) Completely removes the SESSION object SESSION from Hunchentoot's internal session database.","title":"remove-session"},{"location":"hunchentoot/#slots_3","text":"","title":"SLOTS"},{"location":"hunchentoot/#session-id","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_1","text":"Initform: (hunchentoot:user-agent hunchentoot:*request*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_2","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start","text":"Initform: (GET-UNIVERSAL-TIME) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#last-click","text":"The last time this session was used.","title":"last-click"},{"location":"hunchentoot/#session-data","text":"Initargs: :session-data Data associated with this session - see SESSION-VALUE.","title":"session-data"},{"location":"hunchentoot/#max-time","text":"Type: fixnum Initargs: :max-time Initform: hunchentoot:*session-max-time* Readers: hunchentoot:session-max-time Writers: (setf hunchentoot:session-max-time) The time (in seconds) after which this session expires if it's not used.","title":"max-time"},{"location":"hunchentoot/#session-id_1","text":"Type: integer Initform: (hunchentoot:next-session-id (hunchentoot:request-acceptor hunchentoot:*request*)) Readers: hunchentoot:session-id The unique ID (an INTEGER) of the session.","title":"session-id"},{"location":"hunchentoot/#session-string_1","text":"The session string encodes enough data to safely retrieve this session. It is sent to the browser as a cookie value or as a GET parameter.","title":"session-string"},{"location":"hunchentoot/#user-agent_2","text":"Initform: (HUNCHENTOOT:USER-AGENT HUNCHENTOOT:*REQUEST*) Readers: hunchentoot:session-user-agent The incoming 'User-Agent' header that was sent when this session was created.","title":"user-agent"},{"location":"hunchentoot/#remote-addr_3","text":"Initform: (hunchentoot:real-remote-addr hunchentoot:*request*) Readers: hunchentoot:session-remote-addr The remote IP address of the client when this session was started as returned by REAL-REMOTE-ADDR.","title":"remote-addr"},{"location":"hunchentoot/#session-start_1","text":"Initform: (get-universal-time) Readers: hunchentoot:session-start The time this session was started.","title":"session-start"},{"location":"hunchentoot/#9-miscellaneous-functions","text":"","title":"9. MISCELLANEOUS FUNCTIONS"},{"location":"hunchentoot/#bad-request","text":"Class Direct superclasses: HUNCHENTOOT-ERROR No subclasses.","title":"bad-request"},{"location":"hunchentoot/#client-as-string","text":"Function: (client-as-string socket) A helper function which returns the client's address and port as a string and tries to act robustly in the presence of network problems.","title":"client-as-string"},{"location":"hunchentoot/#create-folder-dispatcher-and-handler","text":"Function: (create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type) Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to BASE-PATH that is denoted by the URI of the request relative to URI-PREFIX. URI-PREFIX must be a string ending with a slash, BASE-PATH must be a pathname designator for an existing directory. If CONTENT-TYPE is not NIL, it'll be the content type used for all files in the folder.","title":"create-folder-dispatcher-and-handler"},{"location":"hunchentoot/#create-prefix-dispatcher","text":"Function: (create-prefix-dispatcher prefix handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request starts with the string PREFIX.","title":"create-prefix-dispatcher"},{"location":"hunchentoot/#create-regex-dispatcher","text":"Function: (create-regex-dispatcher regex handler) Creates a request dispatch function which will dispatch to the function denoted by HANDLER if the file name of the current request matches the CL-PPCRE regular expression REGEX.","title":"create-regex-dispatcher"},{"location":"hunchentoot/#create-request-handler-thread","text":"Function: (create-request-handler-thread taskmaster socket) Create a new thread in which to process the request. This thread will call PROCESS-CONNECTION to process the request.","title":"create-request-handler-thread"},{"location":"hunchentoot/#create-static-file-dispatcher-and-handler","text":"Function: (create-static-file-dispatcher-and-handler uri path &optional content-type) Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix.","title":"create-static-file-dispatcher-and-handler"},{"location":"hunchentoot/#decrement-taskmaster-thread-count","text":"Function: (decrement-taskmaster-thread-count taskmaster) Atomically decrement the number of taskmaster requests","title":"decrement-taskmaster-thread-count"},{"location":"hunchentoot/#default-document-directory","text":"Function: (default-document-directory &optional sub-directory)","title":"default-document-directory"},{"location":"hunchentoot/#detach-socket_1","text":"Function: (detach-socket acceptor) Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function.","title":"detach-socket"},{"location":"hunchentoot/#dispatch-easy-handlers","text":"Function: (dispatch-easy-handlers request) This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one.","title":"dispatch-easy-handlers"},{"location":"hunchentoot/#escape-for-html","text":"Function: (escape-for-html string) Escapes the characters #\\<, #>, #\\', #\\\", and #\\& for HTML output.","title":"escape-for-html"},{"location":"hunchentoot/#handle-if-modified-since","text":"Function: (handle-if-modified-since time &optional (request *request*)) Handles the 'If-Modified-Since' header of REQUEST. The date string is compared to the one generated from the supplied universal time TIME.","title":"handle-if-modified-since"},{"location":"hunchentoot/#handle-static-file","text":"Function: (handle-static-file pathname &optional content-type) A function which acts like a Hunchentoot handler for the file denoted by PATHNAME. Sends a content type header corresponding to CONTENT-TYPE or (if that is NIL) tries to determine the content type via the file's suffix.","title":"handle-static-file"},{"location":"hunchentoot/#http-token-p","text":"Function: (http-token-p token) This function tests whether OBJECT is a non-empty string which is a TOKEN according to RFC 2068 (i.e. whether it may be used for, say, cookie names).","title":"http-token-p"},{"location":"hunchentoot/#hunchentoot-error","text":"Function: (hunchentoot-error format-control &rest format-arguments) Signals an error of type HUNCHENTOOT-SIMPLE-ERROR with the provided format control and arguments. Superclass for all errors related to Hunchentoot.","title":"hunchentoot-error"},{"location":"hunchentoot/#increment-taskmaster-thread-count","text":"Function: (increment-taskmaster-thread-count taskmaster) Atomically increment the number of taskmaster requests.","title":"increment-taskmaster-thread-count"},{"location":"hunchentoot/#initialize-connection-stream_1","text":"Function: (initialize-connection-stream acceptor stream) Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use.","title":"initialize-connection-stream"},{"location":"hunchentoot/#log-message","text":"Function: (log-message* log-level format-string &rest format-arguments) Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. This is the function which Hunchentoot itself uses to log errors it catches during request processing.","title":"log-message*"},{"location":"hunchentoot/#maybe-invoke-debugger","text":"Function: (maybe-invoke-debugger condition) This generic function is called whenever a condition CONDITION is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes.","title":"maybe-invoke-debugger"},{"location":"hunchentoot/#mime-type","text":"Function: (mime-type pathspec) Given a pathname designator PATHSPEC returns the MIME type (as a string) corresponding to the suffix of the file denoted by PATHSPEC (or NIL).","title":"mime-type"},{"location":"hunchentoot/#next-session-id","text":"Function: (next-session-id acceptor) Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation.","title":"next-session-id"},{"location":"hunchentoot/#no-cache","text":"Function: (no-cache) Adds appropriate headers to completely prevent caching on most browsers.","title":"no-cache"},{"location":"hunchentoot/#parameter-error","text":"Function: (parameter-error format-control &rest format-arguments) Signals an error of type PARAMETER-ERROR with the provided format control and arguments. Signalled if a function was called with incosistent or illegal parameters.","title":"parameter-error"},{"location":"hunchentoot/#process-connection_1","text":"Function: (process-connection acceptor socket) This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in SOCKET. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing.","title":"process-connection"},{"location":"hunchentoot/#reason-phrase","text":"Function: (reason-phrase return-code) Returns a reason phrase for the HTTP return code RETURN-CODE (which should be an integer) or NIL for return codes Hunchentoot doesn't know.","title":"reason-phrase"},{"location":"hunchentoot/#redirect","text":"Function: (redirect target &key (host (host *request*) host-provided-p) port (protocol (if (ssl-p) :https :http)) (add-session-id (not (or host-provided-p (starts-with-scheme-p target) (cookie-in (session-cookie-name *acceptor*))))) (code +http-moved-temporarily+)) Redirects the browser to TARGET which should be a string. If TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL are ignored. Otherwise, TARGET should denote the path part of a URL, PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET. Adds a session ID if ADD-SESSION-ID is true. If CODE is a 3xx redirection code, it will be sent as status code.","title":"redirect"},{"location":"hunchentoot/#regenerate-session-cookie-value","text":"Function: (regenerate-session-cookie-value session) Regenerates the cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value.","title":"regenerate-session-cookie-value"},{"location":"hunchentoot/#reply-external-format_1","text":"Function: (reply-external-format* &optional (reply *reply*)) The external format of REPLY which is used for character output.","title":"reply-external-format*"},{"location":"hunchentoot/#request-pathname","text":"Function: (request-pathname &optional (request *request*) drop-prefix) Construct a relative pathname from the request's SCRIPT-NAME. If DROP-PREFIX is given, pathname construction starts at the first path segment after the prefix.","title":"request-pathname"},{"location":"hunchentoot/#require-authorization","text":"Function: (require-authorization &optional (realm hunchentoot)) Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm REALM.","title":"require-authorization"},{"location":"hunchentoot/#reset-connection-stream_1","text":"Function: (reset-connection-stream acceptor stream) Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream.","title":"reset-connection-stream"},{"location":"hunchentoot/#reset-session-secret","text":"Function: (reset-session-secret) Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid.","title":"reset-session-secret"},{"location":"hunchentoot/#reset-sessions","text":"Function: (reset-sessions &optional (acceptor *acceptor*)) Removes ALL stored sessions of ACCEPTOR.","title":"reset-sessions"},{"location":"hunchentoot/#rfc-1123-date","text":"Function: (rfc-1123-date &optional (time (get-universal-time))) Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE.","title":"rfc-1123-date"},{"location":"hunchentoot/#script-name_2","text":"Function: (script-name object)","title":"script-name"},{"location":"hunchentoot/#server-protocol_2","text":"Function: (server-protocol object)","title":"server-protocol"},{"location":"hunchentoot/#session-cookie-name","text":"Function: (session-cookie-name acceptor) Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string \"hunchentoot-session\", but you can specialize this function if you want another name.","title":"session-cookie-name"},{"location":"hunchentoot/#session-cookie-value","text":"Function: (session-cookie-value session) Returns a string which can be used to safely restore the session SESSION if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects.","title":"session-cookie-value"},{"location":"hunchentoot/#session-created","text":"Function: (session-created acceptor new-session) This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored.","title":"session-created"},{"location":"hunchentoot/#session-db","text":"Function: (session-db acceptor) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors.","title":"session-db"},{"location":"hunchentoot/#session-db-lock","text":"Function: (session-db-lock acceptor &key whole-db-p) A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the ACCEPTOR argument) for Lisps that support threads and NIL otherwise.","title":"session-db-lock"},{"location":"hunchentoot/#session-gc","text":"Function: (session-gc) Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P.","title":"session-gc"},{"location":"hunchentoot/#session-too-old-p","text":"Function: (session-too-old-p session) Returns true if the SESSION object SESSION has not been active in the last (SESSION-MAX-TIME SESSION) seconds.","title":"session-too-old-p"},{"location":"hunchentoot/#session-verify","text":"Function: (session-verify request) Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object REQUEST. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions.","title":"session-verify"},{"location":"hunchentoot/#set-cookie","text":"Function: (set-cookie name &key (value \"\") expires max-age path domain secure http-only (reply *reply*)) Creates a cookie object from the parameters provided and adds it to the outgoing cookies of the REPLY object REPLY. If a cookie with the name NAME (case-sensitive) already exists, it is replaced.","title":"set-cookie"},{"location":"hunchentoot/#set-cookie_1","text":"Function: (set-cookie* cookie &optional (reply *reply*)) Adds the COOKIE object COOKIE to the outgoing cookies of the REPLY object REPLY. If a cookie with the same name (case-sensitive) already exists, it is replaced.","title":"set-cookie*"},{"location":"hunchentoot/#ssl-p","text":"Function: (ssl-p &optional (acceptor *acceptor*)) Whether the current connection to the client is secure. See ACCEPTOR-SSL-P.","title":"ssl-p"},{"location":"hunchentoot/#taskmaster-max-accept-count","text":"Function: (taskmaster-max-accept-count taskmaster) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"taskmaster-max-accept-count"},{"location":"hunchentoot/#taskmaster-max-thread-count","text":"Function: (taskmaster-max-thread-count taskmaster) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"taskmaster-max-thread-count"},{"location":"hunchentoot/#taskmaster-thread-count","text":"Function: (taskmaster-thread-count taskmaster) Returns the current number of taskmaster requests.","title":"taskmaster-thread-count"},{"location":"hunchentoot/#too-many-taskmaster-requests","text":"Function: (too-many-taskmaster-requests taskmaster socket) Signal a \"too many requests\" error, just prior to closing the connection.","title":"too-many-taskmaster-requests"},{"location":"hunchentoot/#url-decode","text":"Function: (url-decode string &optional (external-format *hunchentoot-default-external-format*)) Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-decode"},{"location":"hunchentoot/#url-encode","text":"Function: (url-encode string &optional (external-format *hunchentoot-default-external-format*)) URL-encodes a string using the external format EXTERNAL-FORMAT. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"url-encode"},{"location":"hunchentoot/#within-request-p","text":"Function: (within-request-p) True if we're in the context of a request, otherwise nil.","title":"within-request-p"},{"location":"hunchentoot/#10-configuration-variables","text":"","title":"10. CONFIGURATION VARIABLES"},{"location":"hunchentoot/#catch-errors-p","text":"Variable Whether Hunchentoot should catch and log errors (or rather invoke the debugger).","title":"*catch-errors-p*"},{"location":"hunchentoot/#content-types-for-url-rewrite","text":"Variable The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS* .","title":"*content-types-for-url-rewrite*"},{"location":"hunchentoot/#default-connection-timeout","text":"Variable The default connection timeout used when an acceptor is reading from and writing to a socket stream.","title":"*default-connection-timeout*"},{"location":"hunchentoot/#default-content-type","text":"Variable The default content-type header which is returned to the client. If this is text content type, the character set used for encoding the response will automatically be added to the content type in a ``charset'' attribute.","title":"*default-content-type*"},{"location":"hunchentoot/#dispatch-table","text":"Variable A global list of dispatch functions.","title":"*dispatch-table*"},{"location":"hunchentoot/#file-upload-hook","text":"Variable If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created.","title":"*file-upload-hook*"},{"location":"hunchentoot/#handle-http-errors-p","text":"","title":"*handle-http-errors-p*"},{"location":"hunchentoot/#header-stream","text":"Variable If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes.","title":"*header-stream*"},{"location":"hunchentoot/#http-error-handler","text":"","title":"*http-error-handler*"},{"location":"hunchentoot/#hunchentoot-default-external-format","text":"Variable The external format used to compute the REQUEST object.","title":"*hunchentoot-default-external-format*"},{"location":"hunchentoot/#hunchentoot-version","text":"","title":"*hunchentoot-version*"},{"location":"hunchentoot/#lisp-errors-log-level","text":"Variable Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO.","title":"*lisp-errors-log-level*"},{"location":"hunchentoot/#lisp-warnings-log-level","text":"Variable Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO.","title":"*lisp-warnings-log-level*"},{"location":"hunchentoot/#log-lisp-backtraces-p","text":"Variable Whether Lisp backtraces should be logged. Only has an effect if [*LOG-LISP-ERRORS-P*](#log-lisp-errors-p] is true as well.","title":"*log-lisp-backtraces-p*"},{"location":"hunchentoot/#log-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be logged.","title":"*log-lisp-errors-p*"},{"location":"hunchentoot/#log-lisp-warnings-p","text":"Variable Whether Lisp warnings in request handlers should be logged.","title":"*log-lisp-warnings-p*"},{"location":"hunchentoot/#methods-for-post-parameters","text":"Variable A list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS .","title":"*methods-for-post-parameters*"},{"location":"hunchentoot/#rewrite-for-session-urls","text":"Variable Whether HTML pages should possibly be rewritten for cookie-less session-management.","title":"*rewrite-for-session-urls*"},{"location":"hunchentoot/#session-gc-frequency","text":"Variable A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED .","title":"*session-gc-frequency*"},{"location":"hunchentoot/#session-max-time","text":"Variable The default time (in seconds) after which a session times out.","title":"*session-max-time*"},{"location":"hunchentoot/#session-secret","text":"Variable A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET ) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors.","title":"*session-secret*"},{"location":"hunchentoot/#show-lisp-backtraces-p","text":"Variable Whether Lisp errors shown in HTML output should contain backtrace information.","title":"*show-lisp-backtraces-p*"},{"location":"hunchentoot/#show-lisp-errors-p","text":"Variable Whether Lisp errors in request handlers should be shown in HTML output.","title":"*show-lisp-errors-p*"},{"location":"hunchentoot/#tmp-directory","text":"Variable Directory for temporary files created by MAKE-TMP-FILE-NAME.","title":"*tmp-directory*"},{"location":"hunchentoot/#use-remote-addr-for-sessions","text":"Variable Whether the client's remote IP (as returned by REAL-REMOTE-ADDR ) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X_FORWARDED_FOR' headers.","title":"*use-remote-addr-for-sessions*"},{"location":"hunchentoot/#use-user-agent-for-sessions","text":"Variable Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header.","title":"*use-user-agent-for-sessions*"},{"location":"hunchentoot/#11-variables-in-the-context-of-a-request","text":"","title":"11. VARIABLES IN THE CONTEXT OF A REQUEST"},{"location":"hunchentoot/#acceptor_1","text":"Variable The current ACCEPTOR object.","title":"*acceptor*"},{"location":"hunchentoot/#reply","text":"Variable The current REPLY object.","title":"*reply*"},{"location":"hunchentoot/#request","text":"Variable The current REQUEST object.","title":"*request*"},{"location":"hunchentoot/#session_1","text":"Variable The current SESSION (can be NIL).","title":"*session*"},{"location":"hunchentoot/#12-constants","text":"","title":"12. CONSTANTS"},{"location":"hunchentoot/#http-accepted","text":"Constant: 202 HTTP return code (202) for 'Accepted'.","title":"+http-accepted+"},{"location":"hunchentoot/#http-authorization-required","text":"Constant: 401 HTTP return code (401) for 'Authorization Required'.","title":"+http-authorization-required+"},{"location":"hunchentoot/#http-bad-gateway","text":"Constant: 502 HTTP return code (502) for 'Bad Gateway'.","title":"+http-bad-gateway+"},{"location":"hunchentoot/#http-bad-request","text":"Constant: 400 HTTP return code (400) for 'Bad Request'.","title":"+http-bad-request+"},{"location":"hunchentoot/#http-conflict","text":"Constant: 409 HTTP return code (409) for 'Conflict'.","title":"+http-conflict+"},{"location":"hunchentoot/#http-continue","text":"Constant: 100 HTTP return code (100) for 'Continue'.","title":"+http-continue+"},{"location":"hunchentoot/#http-created","text":"Constant: 201 HTTP return code (201) for 'Created'.","title":"+http-created+"},{"location":"hunchentoot/#http-expectation-failed","text":"Constant: 417 HTTP return code (417) for 'Expectation Failed'.","title":"+http-expectation-failed+"},{"location":"hunchentoot/#http-failed-dependency","text":"Constant: 424 HTTP return code (424) for 'Failed Dependency'.","title":"+http-failed-dependency+"},{"location":"hunchentoot/#http-forbidden","text":"Constant: 403 HTTP return code (403) for 'Forbidden'.","title":"+http-forbidden+"},{"location":"hunchentoot/#http-gateway-time-out","text":"Constant: 504 HTTP return code (504) for 'Gateway Time-out'.","title":"+http-gateway-time-out+"},{"location":"hunchentoot/#http-gone","text":"Constant: 410 HTTP return code (410) for 'Gone'.","title":"+http-gone+"},{"location":"hunchentoot/#http-internal-server-error","text":"Constant: 500 HTTP return code (500) for 'Internal Server Error'.","title":"+http-internal-server-error+"},{"location":"hunchentoot/#http-length-required","text":"Constant: 411 HTTP return code (411) for 'Length Required'.","title":"+http-length-required+"},{"location":"hunchentoot/#http-method-not-allowed","text":"Constant: 405 HTTP return code (405) for 'Method Not Allowed'.","title":"+http-method-not-allowed+"},{"location":"hunchentoot/#http-moved-permanently","text":"Constant: 301 HTTP return code (301) for 'Moved Permanently'.","title":"+http-moved-permanently+"},{"location":"hunchentoot/#http-moved-temporarily","text":"Constant: 302 HTTP return code (302) for 'Moved Temporarily'.","title":"+http-moved-temporarily+"},{"location":"hunchentoot/#http-multi-status","text":"Constant: 207 HTTP return code (207) for 'Multi-Status'.","title":"+http-multi-status+"},{"location":"hunchentoot/#http-multiple-choices","text":"Constant: 300 HTTP return code (300) for 'Multiple Choices'.","title":"+http-multiple-choices+"},{"location":"hunchentoot/#http-network-authentication-required","text":"Constant: 511 HTTP return code (511) for 'Network Authentication Required'.","title":"+http-network-authentication-required+"},{"location":"hunchentoot/#http-no-content","text":"Constant: 204 HTTP return code (204) for 'No Content'.","title":"+http-no-content+"},{"location":"hunchentoot/#http-non-authoritative-information","text":"Constant: 203 HTTP return code (203) for 'Non-Authoritative Information'.","title":"+http-non-authoritative-information+"},{"location":"hunchentoot/#http-not-acceptable","text":"Constant: 406 HTTP return code (406) for 'Not Acceptable'.","title":"+http-not-acceptable+"},{"location":"hunchentoot/#http-not-found","text":"Constant: 404 HTTP return code (404) for 'Not Found'.","title":"+http-not-found+"},{"location":"hunchentoot/#http-not-implemented","text":"Constant: 501 HTTP return code (501) for 'Not Implemented'.","title":"+http-not-implemented+"},{"location":"hunchentoot/#http-not-modified","text":"Constant: 304 HTTP return code (304) for 'Not Modified'.","title":"+http-not-modified+"},{"location":"hunchentoot/#http-ok","text":"Constant: 200 HTTP return code (200) for 'OK'.","title":"+http-ok+"},{"location":"hunchentoot/#http-partial-content","text":"Constant: 206 HTTP return code (206) for 'Partial Content'.","title":"+http-partial-content+"},{"location":"hunchentoot/#http-payment-required","text":"Constant: 402 HTTP return code (402) for 'Payment Required'.","title":"+http-payment-required+"},{"location":"hunchentoot/#http-precondition-failed","text":"Constant: 412 HTTP return code (412) for 'Precondition Failed'.","title":"+http-precondition-failed+"},{"location":"hunchentoot/#http-precondition-required","text":"Constant: 428 HTTP return code (428) for 'Precondition Required'.","title":"+http-precondition-required+"},{"location":"hunchentoot/#http-proxy-authentication-required","text":"Constant: 407 HTTP return code (407) for 'Proxy Authentication Required'.","title":"+http-proxy-authentication-required+"},{"location":"hunchentoot/#http-request-entity-too-large","text":"Constant: 413 HTTP return code (413) for 'Request Entity Too Large'.","title":"+http-request-entity-too-large+"},{"location":"hunchentoot/#http-request-header-fields-too-large","text":"Constant: 431 HTTP return code (431) for 'Request Header Fields Too Large'.","title":"+http-request-header-fields-too-large+"},{"location":"hunchentoot/#http-request-time-out","text":"Constant: 408 HTTP return code (408) for 'Request Time-out'.","title":"+http-request-time-out+"},{"location":"hunchentoot/#http-request-uri-too-large","text":"Constant: 414 HTTP return code (414) for 'Request-URI Too Large'.","title":"+http-request-uri-too-large+"},{"location":"hunchentoot/#http-requested-range-not-satisfiable","text":"Constant: 416 HTTP return code (416) for 'Requested range not satisfiable'.","title":"+http-requested-range-not-satisfiable+"},{"location":"hunchentoot/#http-reset-content","text":"Constant: 205 HTTP return code (205) for 'Reset Content'.","title":"+http-reset-content+"},{"location":"hunchentoot/#http-see-other","text":"Constant: 303 HTTP return code (303) for 'See Other'.","title":"+http-see-other+"},{"location":"hunchentoot/#http-service-unavailable","text":"Constant: 503 HTTP return code (503) for 'Service Unavailable'.","title":"+http-service-unavailable+"},{"location":"hunchentoot/#http-switching-protocols","text":"Constant: 101 HTTP return code (101) for 'Switching Protocols'.","title":"+http-switching-protocols+"},{"location":"hunchentoot/#http-temporary-redirect","text":"Constant: 307 HTTP return code (307) for 'Temporary Redirect'.","title":"+http-temporary-redirect+"},{"location":"hunchentoot/#http-too-many-requests","text":"Constant: 429 HTTP return code (429) for 'Too Many Requests'.","title":"+http-too-many-requests+"},{"location":"hunchentoot/#http-unsupported-media-type","text":"Constant: 415 HTTP return code (415) for 'Unsupported Media Type'.","title":"+http-unsupported-media-type+"},{"location":"hunchentoot/#http-use-proxy","text":"Constant: 305 HTTP return code (305) for 'Use Proxy'.","title":"+http-use-proxy+"},{"location":"hunchentoot/#http-version-not-supported","text":"Constant: 505 HTTP return code (505) for 'Version not supported'.","title":"+http-version-not-supported+"},{"location":"hunchentoot/#13-hunchentoot-condition","text":"Class Superclass for all conditions related to Hunchentoot.","title":"13. HUNCHENTOOT-CONDITION"},{"location":"hunchentoot/#14-hunchentoot-warning","text":"Class Superclass for all warnings related to Hunchentoot.","title":"14. HUNCHENTOOT-WARNING"},{"location":"hunchentoot/#15-taskmaster","text":"","title":"15. TASKMASTER"},{"location":"hunchentoot/#taskmaster_1","text":"Class An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an \"abstract\" class in the sense that usually only instances of subclasses of TASKMASTER will be used. Direct superclasses: STANDARD-OBJECT Direct subclasses: MULTI-THREADED-TASKMASTER , SINGLE-THREADED-TASKMASTER","title":"taskmaster"},{"location":"hunchentoot/#relevant-methods_4","text":"","title":"RELEVANT METHODS"},{"location":"hunchentoot/#shutdown","text":"Function: (shutdown taskmaster) Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method.","title":"shutdown"},{"location":"hunchentoot/#execute-acceptor","text":"Function: (execute-acceptor taskmaster) This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread.","title":"execute-acceptor"},{"location":"hunchentoot/#handle-incoming-connection","text":"Function: (handle-incoming-connection taskmaster socket) This function is called by the acceptor to start processing of requests on a new incoming connection. SOCKET is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The SOCKET argument is passed to PROCESS-CONNECTION as an argument.","title":"handle-incoming-connection"},{"location":"hunchentoot/#start-thread","text":"Function: (start-thread taskmaster thunk &key name) Start a name thread in which to call the THUNK, in the context of the given TASKMASTER. Keyword arguments provide TASKMASTER-dependent options. Return a thread object. Hunchentoot taskmaster methods will call it with the taskmaster as the context, allowing hunchentoot extensions to define specialized methods that may e.g. wrap the thunk within a proper set of bindings and condition handlers.","title":"start-thread"},{"location":"hunchentoot/#direct-slots_1","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor_2","text":"Readers: taskmaster-acceptor Writers: (setf taskmaster-acceptor) A backpointer to the acceptor instance this taskmaster works for.","title":"acceptor"},{"location":"hunchentoot/#multi-threaded-taskmaster","text":"Class An abstract class for taskmasters that use multiple threads. For a concrete class to instantiate, use one-thread-per-connection-taskmaster. Direct superclasses: TASKMASTER Direct subclasses: ONE-THREAD-PER-CONNECTION-TASKMASTER","title":"multi-threaded-taskmaster"},{"location":"hunchentoot/#direct-slots_2","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#acceptor-process","text":"A process that accepts incoming connections and hands them off to new processes for request handling.","title":"acceptor-process"},{"location":"hunchentoot/#one-thread-per-connection-taskmaster","text":"Class A taskmaster that starts one thread for listening to incoming requests and one new thread for each incoming connection. If MAX-THREAD-COUNT is null, a new thread will always be created for each request. If MAX-THREAD-COUNT is supplied, the number of request threads is limited to that. Furthermore, if MAX-ACCEPT-COUNT is not supplied, an HTTP 503 will be sent if the thread limit is exceeded. Otherwise, if MAX-ACCEPT-COUNT is supplied, it must be greater than MAX-THREAD-COUNT; in this case, requests are accepted up to MAX-ACCEPT-COUNT, and only then is HTTP 503 sent. It is important to note that MAX-ACCEPT-COUNT and the HTTP 503 behavior described above is racing with the acceptor listen backlog. If we are receiving requests faster than threads can be spawned and 503 sent, the requests will be silently rejected by the kernel. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide MAX-THREAD-COUNT but leave MAX-ACCEPT-COUNT null. This will immediately result in HTTP 503 when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both MAX-THREAD-COUNT and a somewhat larger value for MAX-ACCEPT-COUNT. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be HTTP 503. This is the default taskmaster implementation for multi-threaded Lisp implementations. Direct superclasses: MULTI-THREADED-TASKMASTER No subclasses.","title":"one-thread-per-connection-taskmaster"},{"location":"hunchentoot/#direct-slots_3","text":"","title":"DIRECT SLOTS"},{"location":"hunchentoot/#max-thread-count","text":"Type: (OR INTEGER NULL) Initargs: :max-thread-count Readers: taskmaster-max-thread-count Writers: (setf taskmaster-max-thread-count) The maximum number of request threads this taskmaster will simultaneously run before refusing or queueing new connections requests. If the value is null, then there is no limit.","title":"max-thread-count"},{"location":"hunchentoot/#thread-count","text":"Type: INTEGER Initform: 0 Readers: taskmaster-thread-count Writers: (setf taskmaster-thread-count) The number of taskmaster processing threads currently running.","title":"thread-count"},{"location":"hunchentoot/#thread-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the request count.","title":"thread-count-lock"},{"location":"hunchentoot/#max-accept-count","text":"Type: (OR INTEGER NULL) Initargs: :max-accept-count Readers: taskmaster-max-accept-count Writers: (setf taskmaster-max-accept-count) The maximum number of connections this taskmaster will accept before refusing new connections. If supplied, this must be greater than MAX-THREAD-COUNT. The number of queued requests is the difference between MAX-ACCEPT-COUNT and MAX-THREAD-COUNT.","title":"max-accept-count"},{"location":"hunchentoot/#accept-count","text":"Type: INTEGER Initform: 0 The number of connection currently accepted by the taskmaster. These connections are not ensured to be processed, thay may be waiting for an empty processing slot or rejected because the load is too heavy.","title":"accept-count"},{"location":"hunchentoot/#accept-count-lock","text":"In the absence of 'atomic-incf', we need this to atomically increment and decrement the accept count.","title":"accept-count-lock"},{"location":"hunchentoot/#wait-queue","text":"A queue that we use to wait for a free connection.","title":"wait-queue"},{"location":"hunchentoot/#wait-lock","text":"The lock for the connection wait queue.","title":"wait-lock"},{"location":"hunchentoot/#worker-thread-name-format","text":"Type: (OR STRING NULL) Initargs: :worker-thread-name-format Initform: \"hunchentoot-worker-~A\"","title":"worker-thread-name-format"},{"location":"hunchentoot/#single-threaded-taskmaster","text":"Class A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor \"sister\" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. Direct superclasses: TASKMASTER","title":"single-threaded-taskmaster"},{"location":"hunchentoot/#advanced-topics","text":"","title":"ADVANCED TOPICS"},{"location":"hunchentoot/#customizing-session-behaviour","text":"For everyday session usage, you will probably just use START-SESSION , SESSION-VALUE , and maybe DELETE-SESSION-VALUE and *SESSION* . However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection . By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different \"databases\" . By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION ) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store \"the current session\" (whatever that is in your implementation) in *SESSION* . Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE ) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) reset-session-secret session-cookie-name session-cookie-value session-created next-session-id session-db session-db-lock session-verify","title":"CUSTOMIZING SESSION BEHAVIOUR"},{"location":"hunchentoot/#customizing-acceptor-behaviour","text":"If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR ) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster . This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request , and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM . If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP . If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. start-listening accept-connections acceptor-log-access acceptor-log-message acceptor-status-message detach-socket initialize-connection-stream process-connection reset-connection-stream","title":"CUSTOMIZING ACCEPTOR BEHAVIOUR"},{"location":"hunchentoot/#an-example-of-how-to-subclass-acceptor","text":"This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support. It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (ql:quickload '(\"hunchentoot\" \"drakma\")) ;;; Subclass ACCEPTOR (defclass vhost (hunchentoot:acceptor) ;; slots ((dispatch-table :initform '() :accessor dispatch-table :documentation \"List of dispatch functions\")) ;; options (:default-initargs ; default-initargs must be used :address \"127.0.0.1\")) ; because ACCEPTOR uses it ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod hunchentoot:acceptor-dispatch-request ((vhost vhost) request) ;; try REQUEST on each dispatcher in turn (mapc (lambda (dispatcher) (let ((handler (funcall dispatcher request))) (when handler ; Handler found. FUNCALL it and return result (return-from hunchentoot:acceptor-dispatch-request (funcall handler))))) (dispatch-table vhost)) (call-next-method)) ;;; ====================================================================== ;;; Now all we need to do is test it ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002)) ;;; Populate each dispatch table (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo1) (dispatch-table vhost1)) (push (hunchentoot:create-prefix-dispatcher \"/foo\" 'foo2) (dispatch-table vhost2)) ;;; Define handlers (defun foo1 () \"Hello\") (defun foo2 () \"Goodbye\") ;;; Start VHOSTs (hunchentoot:start vhost1) (hunchentoot:start vhost2) ;;; Make some requests (drakma:http-request \"http://127.0.0.1:50001/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] \"GET /foo HTTP/1.1\" 200 5 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Hello\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"5\") (:DATE . \"Fri, 08 Jun 2012 14:30:39 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; \"OK\" (drakma:http-request \"http://127.0.0.1:50002/foo\") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] \"GET /foo HTTP/1.1\" 200 7 \"-\" \"Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)\" ;;; => ;;; \"Goodbye\" ;;; 200 ;;; ((:CONTENT-LENGTH . \"7\") (:DATE . \"Fri, 08 Jun 2012 14:30:47 GMT\") ;;; (:SERVER . \"Hunchentoot 1.2.3\") (:CONNECTION . \"Close\") ;;; (:CONTENT-TYPE . \"text/html; charset=utf-8\")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; \"OK\" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader.","title":"An example of how to subclass ACCEPTOR"},{"location":"hunchentoot/#taskmasters","text":"As a \"normal\" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil , the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL , then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count . This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+ . The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER , and specialize the generic functions in this section. execute-acceptor handle-incoming-connection start-thread create-request-handler-thread shutdown Decodes a URL-encoded string which is assumed to be encoded using the external format EXTERNAL-FORMAT, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for EXTERNAL-FORMAT is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*.","title":"TASKMASTERS"},{"location":"hunchentoot/#some-more-technical-details","text":"Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Source code can be downloaded from https://github.com/edicl/hunchentoot/archive/v1.2.38.tar.gz . The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot . If you want to send patches, please fork the github repository and send pull requests.","title":"SOME MORE TECHNICAL DETAILS"},{"location":"hunchentoot/#without-clssl","text":"You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it.","title":"Without cl+ssl"},{"location":"hunchentoot/#clbuild","text":"Hunchentoot and its dependencies can also be installed with clbuild .","title":"clbuild"},{"location":"hunchentoot/#gentoo-linux","text":"There's also a port for Gentoo Linux thanks to Matthew Kennedy.","title":"Gentoo Linux"},{"location":"hunchentoot/#running-hunchentoot-on-port-80","text":"Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic.","title":"Running Hunchentoot on port 80"},{"location":"hunchentoot/#hunchentoot-behind-a-proxy","text":"If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server . One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with \"/hunchentoot\" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache.","title":"Hunchentoot behind a proxy"},{"location":"hunchentoot/#support","text":"The development version of Hunchentoot can be found on github . Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests . If you want to make a change, please read this first .","title":"SUPPORT"}]}
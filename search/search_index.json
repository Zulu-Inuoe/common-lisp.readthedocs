{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"common-lisp.readthedocs Introduction Common Lisp documentation - libraries or the HyperSpec - isn't particularly \"modern\" or \"attractive\". Previous Efforts Documentation efforts have been made at: Quickdocs: I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. Quickref: Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. common-lisp.net: Ultimately, this seems to be the place for everything. CLiki: Again, layout and \"at a glance\"! UltraSpec: I liked this. The only trouble? It isn't \"quick\". UltraSpec I liked (the theme of) UltraSpec. I also liked mkdocs - that is what I am using here. What UltraSpec seems to be good for is more largish websites than what is here. And anyways, markdown files and dokuwiki files (which is what UltraSpec uses) are interconvertible (untested - to a fair extent perhaps?) using pandoc . (It is also useful for a ton of other files.) mkdocs As a marketing for mkdocs: mkdocs is simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) mkdocs gh-deploy Done! Current Documentation: (See from the html version of this page , rather than the markdown version.) alexandria bordeaux-threads","title":"index"},{"location":"#common-lispreadthedocs","text":"","title":"common-lisp.readthedocs"},{"location":"#introduction","text":"Common Lisp documentation - libraries or the HyperSpec - isn't particularly \"modern\" or \"attractive\".","title":"Introduction"},{"location":"#previous-efforts","text":"Documentation efforts have been made at: Quickdocs: I didn't like the theme. I want the API at a glance! Honestly, this can improve! But don't look at me. Quickref: Frankly, this is just too much. As a user, all I want to know is \"What can this library do? And, how do I do it? (What functions, macros or anything is available?)\" Therefore, for a user, the only good place I found was the Packages section here. It is, after all, a Reference Manual. common-lisp.net: Ultimately, this seems to be the place for everything. CLiki: Again, layout and \"at a glance\"! UltraSpec: I liked this. The only trouble? It isn't \"quick\".","title":"Previous Efforts"},{"location":"#ultraspec","text":"I liked (the theme of) UltraSpec. I also liked mkdocs - that is what I am using here. What UltraSpec seems to be good for is more largish websites than what is here. And anyways, markdown files and dokuwiki files (which is what UltraSpec uses) are interconvertible (untested - to a fair extent perhaps?) using pandoc . (It is also useful for a ton of other files.)","title":"UltraSpec"},{"location":"#mkdocs","text":"As a marketing for mkdocs: mkdocs is simple as pip install mkdocs # or conda create a .yml configuration file (or copy and edit!) mkdocs gh-deploy Done!","title":"mkdocs"},{"location":"#current-documentation","text":"(See from the html version of this page , rather than the markdown version.) alexandria bordeaux-threads","title":"Current Documentation:"},{"location":"alexandria/","text":"Alexandria Manual - draft version Version: 1.0.0 (This documentation is modified to markdown from here on 01 March, 2020.) Alexandria Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 1. Hash Tables ensure-gethash Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table. copy-hash-table Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default. maphash-keys Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table . maphash-values Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table . hash-table-keys Function: (hash-table-keys table) Returns a list containing the keys of hash table table . hash-table-values Function: (hash-table-values table) Returns a list containing the values of hash table table . hash-table-alist Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table . hash-table-plist Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table . alist-hash-table Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs . plist-hash-table Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs . 2. Data and Control Flow define-constant Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value . destructuring-case Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error ensure-functionf Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function. multiple-value-prog2 Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form . named-lambda Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function. nth-value-or Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil . if-let Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect. when-let Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn . switch Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match. cswitch Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches. eswitch Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches. whichever Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random. xor Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value. disjoin Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned. conjoin Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate. compose Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned. multiple-value-compose Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last. curry Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function . rcurry Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function . 3. Conses proper-list Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error . circular-list Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error . appendf Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument. nconcf Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument. remove-from-plistf Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist . delete-from-plistf Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist . reversef Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place. nreversef Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place. unionf Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place. nunionf Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument. doplist Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values . circular-list-p Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise. circular-tree-p Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise. proper-list-p Function: (proper-list-p object) Returns true if object is a proper list. alist-plist Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order. plist-alist Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order. circular-list Function: (circular-list &rest elements) Creates a circular list of elements . make-circular-list Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element . ensure-car Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned. ensure-cons Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr. ensure-list Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list . flatten Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list. lastcar Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list. (setf Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list. proper-list-length Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list. mappend Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list. map-product Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6)) remove-from-plist Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq . delete-from-plist Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist. set-equal Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false. setp Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test . 4. Sequences proper-sequence Type designator for proper sequences, that is proper lists and sequences that are not lists. deletef Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords . removef Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords . rotate Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it. shuffle Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence. random-elt Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence . emptyp Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence. sequence-of-length-p Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists. length= Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer. copy-sequence Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence . first-elt Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence. (setf first-elt) Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence . last-elt Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence. (setf last-elt) Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence . starts-with Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. starts-with-subseq Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix . ends-with Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list. ends-with-subseq Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix . map-combinations Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function . map-derangements Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence . map-permutations Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence. 5. IO read-file-into-string Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector. 6. Macro Writing once-only Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1) with-gensyms Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to. with-unique-names Macro: (with-unique-names names &body forms) Alias for with-gensyms . featurep Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- . parse-body Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given. parse-ordinary-lambda-list Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed. 7. Symbols ensure-symbol Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external format-symbol Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package . make-keyword Function: (make-keyword name) Interns the string designated by name in the keyword package. make-gensym Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument. make-gensym-list Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument. symbolicate Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package. 8. Arrays array-index Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit . copy-array Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments. 9. Types string-designator A string designator type. A string designator is either a string, a symbol, or a character. coercef Macro: (coercef place type-spec env) Modify-macro for coerce . of-type Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type . type= Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent. 10. Numbers maxf Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers . minf Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers . binomial-coefficient Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k . count-permutations Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n clamp Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number . lerp Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v . factorial Function: (factorial n) Factorial of non-negative integer n . subfactorial Function: (subfactorial n) Subfactorial of the non-negative integer n . gaussian-random Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero. iota Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2) map-iota Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0 mean Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers. median Function: (median sample) Returns median of sample . sample must be a sequence of real numbers. variance Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers. standard-deviation Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"Alexandria Manual - draft version"},{"location":"alexandria/#alexandria-manual-draft-version","text":"Version: 1.0.0 (This documentation is modified to markdown from here on 01 March, 2020.)","title":"Alexandria Manual - draft version"},{"location":"alexandria/#alexandria","text":"Alexandria software and associated documentation are in the public domain: Authors dedicate this work to public domain, for the benefit of the public at large and to the detriment of the authors' heirs and successors. Authors intends this dedication to be an overt act of relinquishment in perpetuity of all present and future rights under copyright law, whether vested or contingent, in the work. Authors understands that such relinquishment of all rights includes the relinquishment of all rights to enforce (by lawsuit or otherwise) those copyrights in the work. Authors recognize that, once placed in the public domain, the work may be freely reproduced, distributed, transmitted, used, modified, built upon, or otherwise exploited by anyone for any purpose, commercial or non-commercial, and in any way, including by methods that have not yet been invented or conceived. In those legislations where public domain dedications are not recognized or possible, Alexandria is distributed under the following terms and conditions: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Alexandria"},{"location":"alexandria/#1-hash-tables","text":"","title":"1. Hash Tables"},{"location":"alexandria/#ensure-gethash","text":"Macro: (ensure-gethash key hash-table &optional default) Like gethash , but if key is not found in the hash-table saves the default under key before returning it. Secondary return value is true if key was already in the table.","title":"ensure-gethash"},{"location":"alexandria/#copy-hash-table","text":"Function: (copy-hash-table table &key key test size rehash-size rehash-threshold) Returns a copy of hash table table , with the same keys and values as the table . The copy has the same properties as the original, unless overridden by the keyword arguments. Before each of the original values is set into the new hash-table, key is invoked on the value. As key defaults to cl:identity , a shallow copy is returned by default.","title":"copy-hash-table"},{"location":"alexandria/#maphash-keys","text":"Function: (maphash-keys function table) Like maphash , but calls function with each key in the hash table table .","title":"maphash-keys"},{"location":"alexandria/#maphash-values","text":"Function: (maphash-values function table) Like maphash , but calls function with each value in the hash table table .","title":"maphash-values"},{"location":"alexandria/#hash-table-keys","text":"Function: (hash-table-keys table) Returns a list containing the keys of hash table table .","title":"hash-table-keys"},{"location":"alexandria/#hash-table-values","text":"Function: (hash-table-values table) Returns a list containing the values of hash table table .","title":"hash-table-values"},{"location":"alexandria/#hash-table-alist","text":"Function: (hash-table-alist table) Returns an association list containing the keys and values of hash table table .","title":"hash-table-alist"},{"location":"alexandria/#hash-table-plist","text":"Function: (hash-table-plist table) Returns a property list containing the keys and values of hash table table .","title":"hash-table-plist"},{"location":"alexandria/#alist-hash-table","text":"Function: (alist-hash-table alist &rest hash-table-initargs) Returns a hash table containing the keys and values of the association list alist . Hash table is initialized using the hash-table-initargs .","title":"alist-hash-table"},{"location":"alexandria/#plist-hash-table","text":"Function: (plist-hash-table plist &rest hash-table-initargs) Returns a hash table containing the keys and values of the property list plist . Hash table is initialized using the hash-table-initargs .","title":"plist-hash-table"},{"location":"alexandria/#2-data-and-control-flow","text":"","title":"2.  Data and Control Flow"},{"location":"alexandria/#define-constant","text":"Macro: (define-constant name initial-value &key test documentation) Ensures that the global variable named by name is a constant with a value that is equal under test to the result of evaluating initial-value . test is a /function designator/ that defaults to eql . If documentation is given, it becomes the documentation string of the constant. Signals an error if name is already a bound non-constant variable. Signals an error if name is already a constant variable whose value is not equal under test to result of evaluating initial-value .","title":"define-constant"},{"location":"alexandria/#destructuring-case","text":"Macro: (destructuring-case keyform &body clauses) destructuring-case , -ccase , and -ecase are a combination of case and destructuring-bind . keyform must evaluate to a cons . Clauses are of the form: ((CASE-KEYS . DESTRUCTURING-LAMBDA-LIST) FORM*) The clause whose case-keys matches car of key , as if by case , ccase , or ecase , is selected, and FORMs are then executed with cdr of key is destructured and bound by the destructuring-lambda-list . Example: (defun dcase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)) ((t &rest rest) (format nil \"unknown: ~S\" rest)))) (dcase (list :foo 1 2)) ; =\"foo: 1, 2\" (dcase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (dcase (list :alt1 1)) ; =\"alt: 1\" (dcase (list :alt2 2)) ; =\"alt: 2\" (dcase (list :quux 1 2 3)) ; =\"unknown: 1, 2, 3\" (defun decase (x) (destructuring-case x ((:foo a b) (format nil \"foo: ~S, ~S\" a b)) ((:bar &key a b) (format nil \"bar, ~S, ~S\" a b)) (((:alt1 :alt2) a) (format nil \"alt: ~S\" a)))) (decase (list :foo 1 2)) ; =\"foo: 1, 2\" (decase (list :bar :a 1 :b 2)) ; =\"bar: 1, 2\" (decase (list :alt1 1)) ; =\"alt: 1\" (decase (list :alt2 2)) ; =\"alt: 2\" (decase (list :quux 1 2 3)) ; =| error","title":"destructuring-case"},{"location":"alexandria/#ensure-functionf","text":"Macro: (ensure-functionf &rest places) Multiple-place modify macro for ensure-function: ensures that each of places contains a function.","title":"ensure-functionf"},{"location":"alexandria/#multiple-value-prog2","text":"Macro: (multiple-value-prog2 first-form second-form &body forms) Evaluates first-form , then second-form , and then forms . Yields as its value all the value returned by second-form .","title":"multiple-value-prog2"},{"location":"alexandria/#named-lambda","text":"Macro: (named-lambda name lambda-list &body body) Expands into a lambda-expression within whose body name denotes the corresponding function.","title":"named-lambda"},{"location":"alexandria/#nth-value-or","text":"Macro: (nth-value-or nth-value &body forms) Evaluates form arguments one at a time, until the nth-value returned by one of the forms is true. It then returns all the values returned by evaluating that form. If none of the forms return a true nth value, this form returns nil .","title":"nth-value-or"},{"location":"alexandria/#if-let","text":"Macro: (if-let bindings &body (then-form &optional else-form)) Creates new variable bindings, and conditionally executes either then-form or else-form . else-form defaults to nil . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, the then-form is executed with the bindings in effect, otherwise the else-form is executed with the bindings in effect.","title":"if-let"},{"location":"alexandria/#when-let","text":"Macro: (when-let bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) All initial-forms are executed sequentially in the specified order. Then all the variables are bound to the corresponding values. If all variables were bound to true values, then forms are executed as an implicit progn . Macro: (when-let* bindings &body forms) Creates new variable bindings, and conditionally executes forms . bindings must be either single binding of the form: (variable initial-form) or a list of bindings of the form: ((variable-1 initial-form-1) (variable-2 initial-form-2) ... (variable-n initial-form-n)) Each initial-form is executed in turn, and the variable bound to the corresponding value. Initial-form expressions can refer to variables previously bound by the when-let* . Execution of when-let* stops immediately if any initial-form evaluates to nil . If all initial-forms evaluate to true, then forms are executed as an implicit progn .","title":"when-let"},{"location":"alexandria/#switch","text":"Macro: (switch whole (object &key test key) &body clauses) Evaluates first matching clause, returning its values, or evaluates and returns the values of default if no keys match.","title":"switch"},{"location":"alexandria/#cswitch","text":"Macro: (cswitch whole (object &key test key) &body clauses) Like switch , but signals a continuable error if no key matches.","title":"cswitch"},{"location":"alexandria/#eswitch","text":"Macro: (eswitch whole (object &key test key) &body clauses) Like switch , but signals an error if no key matches.","title":"eswitch"},{"location":"alexandria/#whichever","text":"Macro: (whichever &rest possibilities env) Evaluates exactly one of possibilities , chosen at random.","title":"whichever"},{"location":"alexandria/#xor","text":"Macro: (xor &rest datums) Evaluates its arguments one at a time, from left to right. If more then one argument evaluates to a true value no further datums are evaluated, and nil is returned as both primary and secondary value. If exactly one argument evaluates to true, its value is returned as the primary value after all the arguments have been evaluated, and t is returned as the secondary value. If no arguments evaluate to true nil is retuned as primary, and t as secondary value.","title":"xor"},{"location":"alexandria/#disjoin","text":"Function: (disjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning the primary value of the first predicate that returns true, without calling the remaining predicates. If none of the predicates returns true, nil is returned.","title":"disjoin"},{"location":"alexandria/#conjoin","text":"Function: (conjoin predicate &rest more-predicates) Returns a function that applies each of predicate and more-predicate functions in turn to its arguments, returning nil if any of the predicates returns false, without calling the remaining predicates. If none of the predicates returns false, returns the primary value of the last predicate.","title":"conjoin"},{"location":"alexandria/#compose","text":"Function: (compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to to each in turn, starting from the rightmost of more-functions , and then calling the next one with the primary value of the last. Function: (ensure-function function-designator) Returns the function designated by function-designator: if function-designator is a function, it is returned, otherwise it must be a function name and its fdefinition is returned.","title":"compose"},{"location":"alexandria/#multiple-value-compose","text":"Function: (multiple-value-compose function &rest more-functions) Returns a function composed of function and more-functions that applies its arguments to each in turn, starting from the rightmost of more-functions , and then calling the next one with all the return values of the last.","title":"multiple-value-compose"},{"location":"alexandria/#curry","text":"Function: (curry function &rest arguments) Returns a function that applies arguments and the arguments it is called with to function .","title":"curry"},{"location":"alexandria/#rcurry","text":"Function: (rcurry function &rest arguments) Returns a function that applies the arguments it is called with and arguments to function .","title":"rcurry"},{"location":"alexandria/#3-conses","text":"","title":"3. Conses"},{"location":"alexandria/#proper-list","text":"Type designator for proper lists. Implemented as a satisfies type, hence not recommended for performance intensive use. Main usefullness as a type designator of the expected type in a type-error .","title":"proper-list"},{"location":"alexandria/#circular-list","text":"Type designator for circular lists. Implemented as a satisfies type, so not recommended for performance intensive use. Main usefullness as the expected-type designator of a type-error .","title":"circular-list"},{"location":"alexandria/#appendf","text":"Macro: (appendf place &rest lists env) Modify-macro for append . Appends lists to the place designated by the first argument.","title":"appendf"},{"location":"alexandria/#nconcf","text":"Macro: (nconcf place &rest lists env) Modify-macro for nconc . Concatenates lists to place designated by the first argument.","title":"nconcf"},{"location":"alexandria/#remove-from-plistf","text":"Macro: (remove-from-plistf place &rest keys env) Modify macro for remove-from-plist .","title":"remove-from-plistf"},{"location":"alexandria/#delete-from-plistf","text":"Macro: (delete-from-plistf place &rest keys env) Modify macro for delete-from-plist .","title":"delete-from-plistf"},{"location":"alexandria/#reversef","text":"Macro: (reversef place env) Modify-macro for reverse . Copies and reverses the list stored in the given place and saves back the result into the place.","title":"reversef"},{"location":"alexandria/#nreversef","text":"Macro: (nreversef place env) Modify-macro for nreverse . Reverses the list stored in the given place by destructively modifying it and saves back the result into the place.","title":"nreversef"},{"location":"alexandria/#unionf","text":"Macro: (unionf place list &rest args env) Modify-macro for union . Saves the union of list and the contents of the place designated by the first argument to the designated place.","title":"unionf"},{"location":"alexandria/#nunionf","text":"Macro: (nunionf place list &rest args env) Modify-macro for nunion . Saves the union of list and the contents of the place designated by the first argument to the designated place. May modify either argument.","title":"nunionf"},{"location":"alexandria/#doplist","text":"Macro: (doplist (key val plist &optional values) &body body) Iterates over elements of plist . body can be preceded by declarations, and is like a tagbody . return may be used to terminate the iteration early. If return is not used, returns values .","title":"doplist"},{"location":"alexandria/#circular-list-p","text":"Function: (circular-list-p object) Returns true if object is a circular list, nil otherwise.","title":"circular-list-p"},{"location":"alexandria/#circular-tree-p","text":"Function: (circular-tree-p object) Returns true if object is a circular tree, nil otherwise.","title":"circular-tree-p"},{"location":"alexandria/#proper-list-p","text":"Function: (proper-list-p object) Returns true if object is a proper list.","title":"proper-list-p"},{"location":"alexandria/#alist-plist","text":"Function: (alist-plist alist) Returns a property list containing the same keys and values as the association list alist in the same order.","title":"alist-plist"},{"location":"alexandria/#plist-alist","text":"Function: (plist-alist plist) Returns an association list containing the same keys and values as the property list plist in the same order.","title":"plist-alist"},{"location":"alexandria/#circular-list_1","text":"Function: (circular-list &rest elements) Creates a circular list of elements .","title":"circular-list"},{"location":"alexandria/#make-circular-list","text":"Function: (make-circular-list length &key initial-element) Creates a circular list of length with the given initial-element .","title":"make-circular-list"},{"location":"alexandria/#ensure-car","text":"Function: (ensure-car thing) If thing is a cons , its car is returned. Otherwise thing is returned.","title":"ensure-car"},{"location":"alexandria/#ensure-cons","text":"Function: (ensure-cons cons) If cons is a cons, it is returned. Otherwise returns a fresh cons with cons in the car, and nil in the cdr.","title":"ensure-cons"},{"location":"alexandria/#ensure-list","text":"Function: (ensure-list list) If list is a list, it is returned. Otherwise returns the list designated by list .","title":"ensure-list"},{"location":"alexandria/#flatten","text":"Function: (flatten tree) Traverses the tree in order, collecting non-null leaves into a list.","title":"flatten"},{"location":"alexandria/#lastcar","text":"Function: (lastcar list) Returns the last element of list . Signals a type-error if list is not a proper list.","title":"lastcar"},{"location":"alexandria/#setf","text":"Function: ((setf lastcar)) Sets the last element of list . Signals a type-error if list is not a proper list.","title":"(setf"},{"location":"alexandria/#proper-list-length","text":"Function: (proper-list-length list) Returns length of list , signalling an error if it is not a proper list.","title":"proper-list-length"},{"location":"alexandria/#mappend","text":"Function: (mappend function &rest lists) Applies function to respective element(s) of each list , appending all the all the result list to a single list. function must return a list.","title":"mappend"},{"location":"alexandria/#map-product","text":"Function: (map-product function list &rest more-lists) Returns a list containing the results of calling function with one argument from list , and one from each of more-lists for each combination of arguments. In other words, returns the product of list and more-lists using function . Example: (map-product 'list '(1 2) '(3 4) '(5 6)) =((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))","title":"map-product"},{"location":"alexandria/#remove-from-plist","text":"Function: (remove-from-plist plist &rest keys) Returns a propery-list with same keys and values as plist , except that keys in the list designated by keys and values corresponding to them are removed. The returned property-list may share structure with the plist , but plist is not destructively modified. Keys are compared using eq .","title":"remove-from-plist"},{"location":"alexandria/#delete-from-plist","text":"Function: (delete-from-plist plist &rest keys) Just like remove-from-plist , but this version may destructively modify the provided plist.","title":"delete-from-plist"},{"location":"alexandria/#set-equal","text":"Function: (set-equal list1 list2 &key test key) Returns true if every element of list1 matches some element of list2 and every element of list2 matches some element of list1 . Otherwise returns false.","title":"set-equal"},{"location":"alexandria/#setp","text":"Function: (setp object &key test key) Returns true if object is a list that denotes a set, nil otherwise. A list denotes a set if each element of the list is unique under key and test .","title":"setp"},{"location":"alexandria/#4-sequences","text":"","title":"4. Sequences"},{"location":"alexandria/#proper-sequence","text":"Type designator for proper sequences, that is proper lists and sequences that are not lists.","title":"proper-sequence"},{"location":"alexandria/#deletef","text":"Macro: (deletef place item &rest remove-keywords env) Modify-macro for delete . Sets place designated by the first argument to the result of calling delete with item , place, and the remove-keywords .","title":"deletef"},{"location":"alexandria/#removef","text":"Macro: (removef place item &rest remove-keywords env) Modify-macro for remove . Sets place designated by the first argument to the result of calling remove with item , place, and the remove-keywords .","title":"removef"},{"location":"alexandria/#rotate","text":"Function: (rotate sequence &optional n) Returns a sequence of the same type as sequence , with the elements of sequence rotated by n: n elements are moved from the end of the sequence to the front if n is positive, and -n elements moved from the front to the end if n is negative. sequence must be a proper sequence. n must be an integer, defaulting to 1 . If absolute value of n is greater then the length of the sequence, the results are identical to calling rotate with (* (signum n) (mod n (length sequence))). Note: the original sequence may be destructively altered, and result sequence may share structure with it.","title":"rotate"},{"location":"alexandria/#shuffle","text":"Function: (shuffle sequence &key start end) Returns a random permutation of sequence bounded by start and end . Original sequece may be destructively modified, and share storage with the original one. Signals an error if sequence is not a proper sequence.","title":"shuffle"},{"location":"alexandria/#random-elt","text":"Function: (random-elt sequence &key start end) Returns a random element from sequence bounded by start and end . Signals an error if the sequence is not a proper non-empty sequence, or if end and start are not proper bounding index designators for sequence .","title":"random-elt"},{"location":"alexandria/#emptyp","text":"Function: (emptyp sequence) Returns true if sequence is an empty sequence. Signals an error if sequence is not a sequence.","title":"emptyp"},{"location":"alexandria/#sequence-of-length-p","text":"Function: (sequence-of-length-p sequence length) Return true if sequence is a sequence of length length . Signals an error if sequence is not a sequence. Returns false for circular lists.","title":"sequence-of-length-p"},{"location":"alexandria/#length","text":"Function: (length= &rest sequences) Takes any number of sequences or integers in any order. Returns true iff the length of all the sequences and the integers are equal. Hint: there's a compiler macro that expands into more efficient code if the first argument is a literal integer.","title":"length="},{"location":"alexandria/#copy-sequence","text":"Function: (copy-sequence type sequence) Returns a fresh sequence of type , which has the same elements as sequence .","title":"copy-sequence"},{"location":"alexandria/#first-elt","text":"Function: (first-elt sequence) Returns the first element of sequence . Signals a type-error if sequence is not a sequence, or is an empty sequence.","title":"first-elt"},{"location":"alexandria/#setf-first-elt","text":"Function: ((setf first-elt)) Sets the first element of sequence . Signals a type-error if sequence is not a sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf first-elt)"},{"location":"alexandria/#last-elt","text":"Function: (last-elt sequence) Returns the last element of sequence . Signals a type-error if sequence is not a proper sequence, or is an empty sequence.","title":"last-elt"},{"location":"alexandria/#setf-last-elt","text":"Function: ((setf last-elt)) Sets the last element of sequence . Signals a type-error if sequence is not a proper sequence, is an empty sequence, or if object cannot be stored in sequence .","title":"(setf last-elt)"},{"location":"alexandria/#starts-with","text":"Function: (starts-with object sequence &key test key) Returns true if sequence is a sequence whose first element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence.","title":"starts-with"},{"location":"alexandria/#starts-with-subseq","text":"Function: (starts-with-subseq prefix sequence &rest args &key return-suffix &allow-other-keys) Test whether the first elements of sequence are the same (as per TEST) as the elements of prefix . If return-suffix is t the functions returns, as a second value, a displaced array pointing to the sequence after prefix .","title":"starts-with-subseq"},{"location":"alexandria/#ends-with","text":"Function: (ends-with object sequence &key test key) Returns true if sequence is a sequence whose last element is eql to object . Returns nil if the sequence is not a sequence or is an empty sequence. Signals an error if sequence is an improper list.","title":"ends-with"},{"location":"alexandria/#ends-with-subseq","text":"Function: (ends-with-subseq suffix sequence &key test) Test whether sequence ends with suffix . In other words: return true if the last (length SUFFIX) elements of sequence are equal to suffix .","title":"ends-with-subseq"},{"location":"alexandria/#map-combinations","text":"Function: (map-combinations function sequence &key start end length copy) Calls function with each combination of length constructable from the elements of the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of sequence , and length to the length of the delimited subsequence. (So unless length is specified there is only a single combination, which has the same elements as the delimited subsequence.) If copy is true (the default) each combination is freshly allocated. If copy is false all combinations are eq to each other, in which case consequences are specified if a combination is modified by function .","title":"map-combinations"},{"location":"alexandria/#map-derangements","text":"Function: (map-derangements function sequence &key start end copy) Calls function with each derangement of the subsequence of sequence denoted by the bounding index designators start and end . Derangement is a permutation of the sequence where no element remains in place. sequence is not modified, but individual derangements are eq to each other. Consequences are unspecified if calling function modifies either the derangement or sequence .","title":"map-derangements"},{"location":"alexandria/#map-permutations","text":"Function: (map-permutations function sequence &key start end length copy) Calls function with each permutation of length constructable from the subsequence of sequence delimited by start and end . start defaults to 0 , end to length of the sequence, and length to the length of the delimited subsequence.","title":"map-permutations"},{"location":"alexandria/#5-io","text":"","title":"5. IO"},{"location":"alexandria/#read-file-into-string","text":"Function: (read-file-into-string pathname &key buffer-size external-format) Return the contents of the file denoted by pathname as a fresh string. The external-format parameter will be passed directly to with-open-file unless it's nil , which means the system default. Function: (read-file-into-byte-vector pathname) Read pathname into a freshly allocated (unsigned-byte 8) vector.","title":"read-file-into-string"},{"location":"alexandria/#6-macro-writing","text":"","title":"6. Macro Writing"},{"location":"alexandria/#once-only","text":"Macro: (once-only specs &body forms) Evaluates forms with symbols specified in specs rebound to temporary variables, ensuring that each initform is evaluated only once. Each of specs must either be a symbol naming the variable to be rebound, or of the form: (symbol initform) Bare symbols in specs are equivalent to (symbol symbol) Example: (defmacro cons1 (x) (once-only (x) `(cons ,x ,x))) (let ((y 0)) (cons1 (incf y))) =(1 . 1)","title":"once-only"},{"location":"alexandria/#with-gensyms","text":"Macro: (with-gensyms names &body forms) Binds each variable named by a symbol in names to a unique symbol around forms . Each of names must either be either a symbol, or of the form: (symbol string-designator) Bare symbols appearing in names are equivalent to: (symbol symbol) The string-designator is used as the argument to gensym when constructing the unique symbol the named variable will be bound to.","title":"with-gensyms"},{"location":"alexandria/#with-unique-names","text":"Macro: (with-unique-names names &body forms) Alias for with-gensyms .","title":"with-unique-names"},{"location":"alexandria/#featurep","text":"Function: (featurep feature-expression) Returns t if the argument matches the state of the *features* list and nil if it does not. feature-expression can be any atom or list acceptable to the reader macros #+ and #- .","title":"featurep"},{"location":"alexandria/#parse-body","text":"Function: (parse-body body &key documentation whole) Parses body into (values remaining-forms declarations doc-string). Documentation strings are recognized only if documentation is true. Syntax errors in body are signalled and whole is used in the signal arguments when given.","title":"parse-body"},{"location":"alexandria/#parse-ordinary-lambda-list","text":"Function: (parse-ordinary-lambda-list lambda-list &key normalize allow-specializers normalize-optional normalize-keyword normalize-auxilary) Parses an ordinary lambda-list, returning as multiple values: 1 . Required parameters. 2 . Optional parameter specifications, normalized into form: (name init suppliedp) 3 . Name of the rest parameter, or nil . 4 . Keyword parameter specifications, normalized into form: ((keyword-name name) init suppliedp) 5 . Boolean indicating &allow-other-keys presence. 6 . &aux parameter specifications, normalized into form (name init). Signals a program-error is the lambda-list is malformed.","title":"parse-ordinary-lambda-list"},{"location":"alexandria/#7-symbols","text":"","title":"7. Symbols"},{"location":"alexandria/#ensure-symbol","text":"Function: (ensure-symbol name &optional package) Returns a symbol with name designated by name , accessible in package designated by package . If symbol is not already accessible in package , it is interned there. Returns a secondary value reflecting the status of the symbol in the package, which matches the secondary return value of intern . Example: (ensure-symbol :cons :cl) =cl:cons, :external","title":"ensure-symbol"},{"location":"alexandria/#format-symbol","text":"Function: (format-symbol package control &rest arguments) Constructs a string by applying arguments to string designator control as if by format within with-standard-io-syntax , and then creates a symbol named by that string. If package is nil , returns an uninterned symbol, if package is t , returns a symbol interned in the current package, and otherwise returns a symbol interned in the package designated by package .","title":"format-symbol"},{"location":"alexandria/#make-keyword","text":"Function: (make-keyword name) Interns the string designated by name in the keyword package.","title":"make-keyword"},{"location":"alexandria/#make-gensym","text":"Function: (make-gensym name) If name is a non-negative integer, calls gensym using it. Otherwise name must be a string designator, in which case calls gensym using the designated string as the argument.","title":"make-gensym"},{"location":"alexandria/#make-gensym-list","text":"Function: (make-gensym-list length &optional x) Returns a list of length gensyms, each generated as if with a call to make-gensym , using the second (optional, defaulting to \"G\") argument.","title":"make-gensym-list"},{"location":"alexandria/#symbolicate","text":"Function: (symbolicate &rest things) Concatenate together the names of some strings and symbols, producing a symbol in the current package.","title":"symbolicate"},{"location":"alexandria/#8-arrays","text":"","title":"8. Arrays"},{"location":"alexandria/#array-index","text":"Type designator for an index into array of `length:` an integer between `0` (inclusive) and `length` (exclusive). `length` defaults to `array-dimension-limit`. ### array-length Type designator for a dimension of an array of length: an integer between 0 (inclusive) and length (inclusive). length defaults to array-dimension-limit .","title":"array-index"},{"location":"alexandria/#copy-array","text":"Function: (copy-array array &key element-type fill-pointer adjustable) Returns an undisplaced copy of array , with same fill-pointer and adjustability (if any) as the original, unless overridden by the keyword arguments.","title":"copy-array"},{"location":"alexandria/#9-types","text":"","title":"9. Types"},{"location":"alexandria/#string-designator","text":"A string designator type. A string designator is either a string, a symbol, or a character.","title":"string-designator"},{"location":"alexandria/#coercef","text":"Macro: (coercef place type-spec env) Modify-macro for coerce .","title":"coercef"},{"location":"alexandria/#of-type","text":"Function: (of-type type) Returns a function of one argument, which returns true when its argument is of type .","title":"of-type"},{"location":"alexandria/#type","text":"Function: (type= type1 type2) Returns a primary value of t is type1 and type2 are the same type, and a secondary value that is true is the type equality could be reliably determined: primary value of nil and secondary value of t indicates that the types are not equivalent.","title":"type="},{"location":"alexandria/#10-numbers","text":"","title":"10. Numbers"},{"location":"alexandria/#maxf","text":"Macro: (maxf place &rest numbers env) Modify-macro for max . Sets place designated by the first argument to the maximum of its original value and numbers .","title":"maxf"},{"location":"alexandria/#minf","text":"Macro: (minf place &rest numbers env) Modify-macro for min . Sets place designated by the first argument to the minimum of its original value and numbers .","title":"minf"},{"location":"alexandria/#binomial-coefficient","text":"Function: (binomial-coefficient n k) Binomial coefficient of n and k , also expressed as n choose k . This is the number of k element combinations given n choises. n must be equal to or greater then k .","title":"binomial-coefficient"},{"location":"alexandria/#count-permutations","text":"Function: (count-permutations n &optional k) Number of k element permutations for a sequence of n objects. k defaults to n","title":"count-permutations"},{"location":"alexandria/#clamp","text":"Function: (clamp number min max) Clamps the number into [min, max] range. Returns min if number is lesser then min and max if number is greater then max , otherwise returns number .","title":"clamp"},{"location":"alexandria/#lerp","text":"Function: (lerp v a b) Returns the result of linear interpolation between A and b , using the interpolation coefficient v .","title":"lerp"},{"location":"alexandria/#factorial","text":"Function: (factorial n) Factorial of non-negative integer n .","title":"factorial"},{"location":"alexandria/#subfactorial","text":"Function: (subfactorial n) Subfactorial of the non-negative integer n .","title":"subfactorial"},{"location":"alexandria/#gaussian-random","text":"Function: (gaussian-random &optional min max) Returns two gaussian random double floats as the primary and secondary value, optionally constrained by min and max . Gaussian random numbers form a standard normal distribution around 0 .0d0. Sufficiently positive min or negative max will cause the algorithm used to take a very long time. If min is positive it should be close to zero, and similarly if max is negative it should be close to zero.","title":"gaussian-random"},{"location":"alexandria/#iota","text":"Function: (iota n &key start step) Return a list of n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Examples: (iota 4) =(0 1 2 3) (iota 3 :start 1 :step 1.0) =(1.0 2.0 3.0) (iota 3 :start -1 :step -1/2) =(-1 -3/2 -2)","title":"iota"},{"location":"alexandria/#map-iota","text":"Function: (map-iota function n &key start step) Calls function with n numbers, starting from start (with numeric contagion from step applied), each consequtive number being the sum of the previous one and step . start defaults to 0 and step to 1 . Returns n . Examples: (map-iota #'print 3 :start 1 :step 1.0) =3 ;;; 1.0 ;;; 2.0 ;;; 3.0","title":"map-iota"},{"location":"alexandria/#mean","text":"Function: (mean sample) Returns the mean of sample . sample must be a sequence of numbers.","title":"mean"},{"location":"alexandria/#median","text":"Function: (median sample) Returns median of sample . sample must be a sequence of real numbers.","title":"median"},{"location":"alexandria/#variance","text":"Function: (variance sample &key biased) Variance of sample . Returns the biased variance if biased is true (the default), and the unbiased estimator of variance if biased is false. sample must be a sequence of numbers.","title":"variance"},{"location":"alexandria/#standard-deviation","text":"Function: (standard-deviation sample &key biased) Standard deviation of sample . Returns the biased standard deviation if biased is true (the default), and the square root of the unbiased estimator for variance if biased is false (which is not the same as the unbiased estimator for standard deviation). sample must be a sequence of numbers.","title":"standard-deviation"},{"location":"bordeaux-threads/","text":"bordeaux-threads Version: 0.8.7 BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: 1) Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. 2) Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. 3) Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. 4) Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages. *default-special-bindings* This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to MAKE-THREAD to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list. *standard-io-bindings* Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX. *supports-threads-p* This should be set to T if the running instance has thread support. acquire-lock Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock LOCK for the calling thread. WAIT-P governs what happens if the lock is not available: if WAIT-P is true, the calling thread will wait until the lock is available and then acquire it; if WAIT-P is NIL, ACQUIRE-LOCK will return immediately. ACQUIRE-LOCK returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead MAKE-RECURSIVE-LOCK and friends. acquire-recursive-lock Function: (acquire-recursive-lock lock) As for ACQUIRE-LOCK, but for recursive locks. all-threads Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it. condition-notify Function: (condition-notify condition-variable) Notify at least one of the threads waiting for CONDITION-VARIABLE. It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. CONDITION-NOTIFY has no useful return value. In an implementation that does not support multiple threads, it has no effect. condition-wait Function: (condition-wait condition-variable lock &key timeout) Atomically release LOCK and enqueue the calling thread waiting for CONDITION-VARIABLE. The thread will resume when another thread has notified it using CONDITION-NOTIFY; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds LOCK. If TIMEOUT is nil or not provided, the system always reacquires LOCK before returning to the caller. In this case T is returned. If TIMEOUT is non-nil, the call will return after at most TIMEOUT seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of CONDITION-WAIT with TIMEOUT diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error. current-thread Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by MAKE-THREAD. destroy-thread Function: (destroy-thread thread) Terminates the thread THREAD, which is an object as returned by MAKE-THREAD. This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error. interrupt-thread Function: (interrupt-thread thread function &rest args) Interrupt THREAD and cause it to evaluate FUNCTION before continuing with the interrupted path of execution. This may not be a good idea if THREAD is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error. join-thread Function: (join-thread thread) Wait until THREAD terminates. If THREAD has already terminated, return immediately. The return values of the thread function are returned. lock lock-p Function: (lock-p object) Returns T if OBJECT is a lock; returns NIL otherwise. make-condition-variable Function: (make-condition-variable &key name) Returns a new condition-variable object for use with CONDITION-WAIT and CONDITION-NOTIFY. make-lock Function: (make-lock &optional name) Creates a lock (a mutex) whose name is NAME. If the system does not support multiple threads this will still return some object, but it may not be used for very much. make-recursive-lock Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is NAME. A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread. make-semaphore Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied NAME and initial counter value COUNT. make-thread Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named NAME, which will call the function FUNCTION with no arguments: when FUNCTION returns, the thread terminates. NAME defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, MAKE-THREAD will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by INITIAL-BINDINGS, are local to the thread they are introduced in, except that Local bindings in the the caller of MAKE-THREAD may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread. recursive-lock recursive-lock-p Function: (recursive-lock-p object) Returns T if OBJECT is a recursive lock; returns NIL otherwise. release-lock Function: (release-lock lock) Release LOCK. It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the ACQUIRE-LOCK call in one of them will now be able to continue. This function has no interesting return value. release-recursive-lock Function: (release-recursive-lock lock) Release the recursive LOCK. The lock will only become free after as many Release operations as there have been Acquire operations. See RELEASE-LOCK for other information. semaphore semaphore-p Function: (semaphore-p object) Returns T if OBJECT is a semaphore; returns NIL otherwise. signal-semaphore Function: (signal-semaphore semaphore &key (count 1)) Increment SEMAPHORE by COUNT. If there are threads waiting on this semaphore, then COUNT of them are woken up. start-multiprocessing Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly. thread thread-alive-p Function: (thread-alive-p thread) Returns true if THREAD is alive, that is, if DESTROY-THREAD has not been called on it. thread-name Function: (thread-name thread) Returns the name of the thread, as supplied to MAKE-THREAD. thread-yield Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing. threadp Function: (threadp object) Returns true if object is a thread, otherwise NIL. timeout wait-on-semaphore Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of SEMAPHORE by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If TIMEOUT is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count. with-lock-held Function: (with-lock-held (place) &body body) Evaluates BODY with the lock named by PLACE, the value of which is a lock created by MAKE-LOCK. Before the forms in BODY are evaluated, the lock is acquired as if by using ACQUIRE-LOCK. After the forms in BODY have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by RELEASE-LOCK. Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted. with-recursive-lock-held Function: (with-recursive-lock-held (place) &body body) Evaluates BODY with the recursive lock named by PLACE, which is a reference to a recursive lock created by MAKE-RECURSIVE-LOCK. See WITH-LOCK-HELD etc etc with-timeout Function: (with-timeout (timeout) &body body)","title":"bordeaux-threads"},{"location":"bordeaux-threads/#bordeaux-threads","text":"Version: 0.8.7 BORDEAUX-THREADS is a proposed standard for a minimal MP/threading interface. It is similar to the CLIM-SYS threading and lock support, but for the following broad differences: 1) Some behaviours are defined in additional detail: attention has been given to special variable interaction, whether and when cleanup forms are run. Some behaviours are defined in less detail: an implementation that does not support multiple threads is not required to use a new list (nil) for a lock, for example. 2) Many functions which would be difficult, dangerous or inefficient to provide on some implementations have been removed. Chiefly these are functions such as thread-wait which expect for efficiency that the thread scheduler is written in Lisp and 'hookable', which can't sensibly be done if the scheduler is external to the Lisp image, or the system has more than one CPU. 3) Unbalanced ACQUIRE-LOCK and RELEASE-LOCK functions have been added. 4) Posix-style condition variables have been added, as it's not otherwise possible to implement them correctly using the other operations that are specified. Threads may be implemented using whatever applicable techniques are provided by the operating system: user-space scheduling, kernel-based LWPs or anything else that does the job. Some parts of this specification can also be implemented in a Lisp that does not support multiple threads. Thread creation and some thread inspection operations will not work, but the locking functions are still present (though they may do nothing) so that thread-safe code can be compiled on both multithread and single-thread implementations without need of conditionals. To avoid conflict with existing MP/threading interfaces in implementations, these symbols live in the BORDEAUX-THREADS package. Implementations and/or users may also make them visible or exported in other more traditionally named packages.","title":"bordeaux-threads"},{"location":"bordeaux-threads/#default-special-bindings","text":"This variable holds an alist associating special variable symbols to forms to evaluate. Special variables named in this list will be locally bound in the new thread before it begins executing user code. This variable may be rebound around calls to MAKE-THREAD to add/alter default bindings. The effect of mutating this list is undefined, but earlier forms take precedence over later forms for the same symbol, so defaults may be overridden by consing to the head of the list.","title":"*default-special-bindings*"},{"location":"bordeaux-threads/#standard-io-bindings","text":"Standard bindings of printer/reader control variables as per CL:WITH-STANDARD-IO-SYNTAX.","title":"*standard-io-bindings*"},{"location":"bordeaux-threads/#supports-threads-p","text":"This should be set to T if the running instance has thread support.","title":"*supports-threads-p*"},{"location":"bordeaux-threads/#acquire-lock","text":"Function: (acquire-lock lock &optional (wait-p t)) Acquire the lock LOCK for the calling thread. WAIT-P governs what happens if the lock is not available: if WAIT-P is true, the calling thread will wait until the lock is available and then acquire it; if WAIT-P is NIL, ACQUIRE-LOCK will return immediately. ACQUIRE-LOCK returns true if the lock was acquired and NIL otherwise. This specification does not define what happens if a thread attempts to acquire a lock that it already holds. For applications that require locks to be safe when acquired recursively, see instead MAKE-RECURSIVE-LOCK and friends.","title":"acquire-lock"},{"location":"bordeaux-threads/#acquire-recursive-lock","text":"Function: (acquire-recursive-lock lock) As for ACQUIRE-LOCK, but for recursive locks.","title":"acquire-recursive-lock"},{"location":"bordeaux-threads/#all-threads","text":"Function: (all-threads) Returns a sequence of all of the threads. This may not be freshly-allocated, so the caller should not modify it.","title":"all-threads"},{"location":"bordeaux-threads/#condition-notify","text":"Function: (condition-notify condition-variable) Notify at least one of the threads waiting for CONDITION-VARIABLE. It is implementation-dependent whether one or more than one (and possibly all) threads are woken, but if the implementation is capable of waking only a single thread (not all are) this is probably preferable for efficiency reasons. The order of wakeup is unspecified and does not necessarily relate to the order that the threads went to sleep in. CONDITION-NOTIFY has no useful return value. In an implementation that does not support multiple threads, it has no effect.","title":"condition-notify"},{"location":"bordeaux-threads/#condition-wait","text":"Function: (condition-wait condition-variable lock &key timeout) Atomically release LOCK and enqueue the calling thread waiting for CONDITION-VARIABLE. The thread will resume when another thread has notified it using CONDITION-NOTIFY; it may also resume if interrupted by some external event or in other implementation-dependent circumstances: the caller must always test on waking that there is threading to be done, instead of assuming that it can go ahead. It is an error to call function this unless from the thread that holds LOCK. If TIMEOUT is nil or not provided, the system always reacquires LOCK before returning to the caller. In this case T is returned. If TIMEOUT is non-nil, the call will return after at most TIMEOUT seconds (approximately), whether or not a notification has occurred. Either NIL or T will be returned. A return of NIL indicates that the lock is no longer held and that the timeout has expired. A return of T indicates that the lock is held, in which case the timeout may or may not have expired. NOTE : The behavior of CONDITION-WAIT with TIMEOUT diverges from the POSIX function pthread_cond_timedwait. The former may return without the lock being held while the latter always returns with the lock held. In an implementation that does not support multiple threads, this function signals an error.","title":"condition-wait"},{"location":"bordeaux-threads/#current-thread","text":"Function: (current-thread) Returns the thread object for the calling thread. This is the same kind of object as would be returned by MAKE-THREAD.","title":"current-thread"},{"location":"bordeaux-threads/#destroy-thread","text":"Function: (destroy-thread thread) Terminates the thread THREAD, which is an object as returned by MAKE-THREAD. This should be used with caution: it is implementation-defined whether the thread runs cleanup forms or releases its locks first. Destroying the calling thread is an error.","title":"destroy-thread"},{"location":"bordeaux-threads/#interrupt-thread","text":"Function: (interrupt-thread thread function &rest args) Interrupt THREAD and cause it to evaluate FUNCTION before continuing with the interrupted path of execution. This may not be a good idea if THREAD is holding locks or doing anything important. On systems that do not support multiple threads, this function signals an error.","title":"interrupt-thread"},{"location":"bordeaux-threads/#join-thread","text":"Function: (join-thread thread) Wait until THREAD terminates. If THREAD has already terminated, return immediately. The return values of the thread function are returned.","title":"join-thread"},{"location":"bordeaux-threads/#lock","text":"","title":"lock"},{"location":"bordeaux-threads/#lock-p","text":"Function: (lock-p object) Returns T if OBJECT is a lock; returns NIL otherwise.","title":"lock-p"},{"location":"bordeaux-threads/#make-condition-variable","text":"Function: (make-condition-variable &key name) Returns a new condition-variable object for use with CONDITION-WAIT and CONDITION-NOTIFY.","title":"make-condition-variable"},{"location":"bordeaux-threads/#make-lock","text":"Function: (make-lock &optional name) Creates a lock (a mutex) whose name is NAME. If the system does not support multiple threads this will still return some object, but it may not be used for very much.","title":"make-lock"},{"location":"bordeaux-threads/#make-recursive-lock","text":"Function: (make-recursive-lock &optional name) Create and return a recursive lock whose name is NAME. A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.","title":"make-recursive-lock"},{"location":"bordeaux-threads/#make-semaphore","text":"Function: (make-semaphore &key name (count 0)) Create a semaphore with the supplied NAME and initial counter value COUNT.","title":"make-semaphore"},{"location":"bordeaux-threads/#make-thread","text":"Function: (make-thread function &key name (initial-bindings *default-special-bindings*)) Creates and returns a thread named NAME, which will call the function FUNCTION with no arguments: when FUNCTION returns, the thread terminates. NAME defaults to \"Anonymous thread\" if unsupplied. On systems that do not support multi-threading, MAKE-THREAD will signal an error. The interaction between threads and dynamic variables is in some cases complex, and depends on whether the variable has only a global binding (as established by e.g. DEFVAR/DEFPARAMETER/top-level SETQ) or has been bound locally (e.g. with LET or LET*) in the calling thread. Global bindings are shared between threads: the initial value of a global variable in the new thread will be the same as in the parent, and an assignment to such a variable in any thread will be visible to all threads in which the global binding is visible. Local bindings, such as the ones introduced by INITIAL-BINDINGS, are local to the thread they are introduced in, except that Local bindings in the the caller of MAKE-THREAD may or may not be shared with the new thread that it creates: this is implementation-defined. Portable code should not depend on particular behaviour in this case, nor should it assign to such variables without first rebinding them in the new thread.","title":"make-thread"},{"location":"bordeaux-threads/#recursive-lock","text":"","title":"recursive-lock"},{"location":"bordeaux-threads/#recursive-lock-p","text":"Function: (recursive-lock-p object) Returns T if OBJECT is a recursive lock; returns NIL otherwise.","title":"recursive-lock-p"},{"location":"bordeaux-threads/#release-lock","text":"Function: (release-lock lock) Release LOCK. It is an error to call this unless the lock has previously been acquired (and not released) by the same thread. If other threads are waiting for the lock, the ACQUIRE-LOCK call in one of them will now be able to continue. This function has no interesting return value.","title":"release-lock"},{"location":"bordeaux-threads/#release-recursive-lock","text":"Function: (release-recursive-lock lock) Release the recursive LOCK. The lock will only become free after as many Release operations as there have been Acquire operations. See RELEASE-LOCK for other information.","title":"release-recursive-lock"},{"location":"bordeaux-threads/#semaphore","text":"","title":"semaphore"},{"location":"bordeaux-threads/#semaphore-p","text":"Function: (semaphore-p object) Returns T if OBJECT is a semaphore; returns NIL otherwise.","title":"semaphore-p"},{"location":"bordeaux-threads/#signal-semaphore","text":"Function: (signal-semaphore semaphore &key (count 1)) Increment SEMAPHORE by COUNT. If there are threads waiting on this semaphore, then COUNT of them are woken up.","title":"signal-semaphore"},{"location":"bordeaux-threads/#start-multiprocessing","text":"Function: (start-multiprocessing) If the host implementation uses user-level threads, start the scheduler and multiprocessing, otherwise do nothing. It is safe to call repeatedly.","title":"start-multiprocessing"},{"location":"bordeaux-threads/#thread","text":"","title":"thread"},{"location":"bordeaux-threads/#thread-alive-p","text":"Function: (thread-alive-p thread) Returns true if THREAD is alive, that is, if DESTROY-THREAD has not been called on it.","title":"thread-alive-p"},{"location":"bordeaux-threads/#thread-name","text":"Function: (thread-name thread) Returns the name of the thread, as supplied to MAKE-THREAD.","title":"thread-name"},{"location":"bordeaux-threads/#thread-yield","text":"Function: (thread-yield) Allows other threads to run. It may be necessary or desirable to call this periodically in some implementations; others may schedule threads automatically. On systems that do not support multi-threading, this does nothing.","title":"thread-yield"},{"location":"bordeaux-threads/#threadp","text":"Function: (threadp object) Returns true if object is a thread, otherwise NIL.","title":"threadp"},{"location":"bordeaux-threads/#timeout","text":"","title":"timeout"},{"location":"bordeaux-threads/#wait-on-semaphore","text":"Function: (wait-on-semaphore semaphore &key timeout) Decrement the count of SEMAPHORE by 1 if the count would not be negative. Else blocks until the semaphore can be decremented. Returns generalized boolean T on success. If TIMEOUT is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns NIL without decrementing the count.","title":"wait-on-semaphore"},{"location":"bordeaux-threads/#with-lock-held","text":"Function: (with-lock-held (place) &body body) Evaluates BODY with the lock named by PLACE, the value of which is a lock created by MAKE-LOCK. Before the forms in BODY are evaluated, the lock is acquired as if by using ACQUIRE-LOCK. After the forms in BODY have been evaluated, or if a non-local control transfer is caused (e.g. by THROW or SIGNAL), the lock is released as if by RELEASE-LOCK. Note that if the debugger is entered, it is unspecified whether the lock is released at debugger entry or at debugger exit when execution is restarted.","title":"with-lock-held"},{"location":"bordeaux-threads/#with-recursive-lock-held","text":"Function: (with-recursive-lock-held (place) &body body) Evaluates BODY with the recursive lock named by PLACE, which is a reference to a recursive lock created by MAKE-RECURSIVE-LOCK. See WITH-LOCK-HELD etc etc","title":"with-recursive-lock-held"},{"location":"bordeaux-threads/#with-timeout","text":"Function: (with-timeout (timeout) &body body)","title":"with-timeout"}]}